#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model EHPTexamples.SHEV.SHEV_OO
 Dymola Version 2023x Refresh 1, 2023-04-12 translated this at Sat May 25 09:53:28 2024

   */

#include <matrixop.h>
#include "matrixop.c"
static double DymArrays1[1]={0.0};
static double DymArrays2[1]={1.0};
#if defined(DynSimStruct)
static double DymArrays0[7]={3.0, 2.0, 1.0, 0.0, -1.0, 1.0, 1.0};
#endif
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
#include "ModelicaStandardTables.h"
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(
  struct DymStruc0 tableID0_0, double  timeIn0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DValue_M(struct 
  DymStruc0 tableID0_0, int  icol0_0, double  u0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DValueNoDer2_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0);
DYMOLA_STATIC RealArray    Modelica_Blocks_Tables_Internal_getTable2DAbscissaUmax_M
  (struct DymStruc0 tableID0_0);
DYMOLA_STATIC RealArray    Modelica_Blocks_Tables_Internal_getTable2DAbscissaUmin_M
  (struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable2DValueNoDer2_M(
  struct DymStruc0 tableID0_0, double  u10_0, double  u20_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmax_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmin_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableValueNoDer2_M
  (struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int  extrapolation0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable2D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, int 
   smoothness0_0, int  extrapolation0_0, int  verboseRead0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable2D_destructor_M(
  void* externalCombiTable2D0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTimeTable_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  double  startTime0_0, IntegerArray   columns0_0, int  smoothness0_0, int  
  extrapolation0_0, double  shiftTime0_0, int  timeEvents0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M(
  void* externalCombiTimeTable0_0);
struct Modelica_Math_Vectors_interpolate_struct {
  double   yi0_0_0member;
  int   iNew0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0);
DYMOLA_STATIC int   Modelica_Utilities_Strings_isEmpty(const char*  string0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getNextTimeEvent
discrete input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete input Real timeIn "(Scaled) time value";
discrete output Real nextTimeEvent "(Scaled) next time event in table";

external "C" equation
nextTimeEvent = ModelicaStandardTables_CombiTimeTable_nextTimeEvent(tableID, timeIn) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getNextTimeEvent;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(
  struct DymStruc0 tableID0_0, double  timeIn0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getNextTimeEvent")
  {
    /* Declare outputs and temporaries */
    double   nextTimeEvent0_0;
    nextTimeEvent0_0=0;
    /* Start of real code */
    {
      nextTimeEvent0_0 = (ModelicaStandardTables_CombiTimeTable_nextTimeEvent)(
        externalTable_[tableID0_0.id_0member].obj_, timeIn0_0);
      }
    /* Output section */
    PopContext()
    return nextTimeEvent0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax
discrete input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
discrete output Real uMax "Maximum abscissa value in table";

external "C" equation
uMax = ModelicaStandardTables_CombiTable1D_maximumAbscissa(tableID) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax")
  {
    /* Declare outputs and temporaries */
    double   uMax0_0;
    uMax0_0=0;
    /* Start of real code */
    {
      uMax0_0 = (ModelicaStandardTables_CombiTable1D_maximumAbscissa)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return uMax0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin
discrete input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
discrete output Real uMin "Minimum abscissa value in table";

external "C" equation
uMin = ModelicaStandardTables_CombiTable1D_minimumAbscissa(tableID) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin")
  {
    /* Declare outputs and temporaries */
    double   uMin0_0;
    uMin0_0=0;
    /* Start of real code */
    {
      uMin0_0 = (ModelicaStandardTables_CombiTable1D_minimumAbscissa)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return uMin0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable1DValue
discrete input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol "Column number";
discrete input Real u "Abscissa value";
discrete output Real y "Interpolated value";

external "C" equation
y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
annotation(derivative=Modelica.Blocks.Tables.Internal.getDerTable1DValue);
end Modelica.Blocks.Tables.Internal.getTable1DValue;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DValue_M(struct 
  DymStruc0 tableID0_0, int  icol0_0, double  u0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable1DValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable1DValueNoDer2
discrete input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol "Column number";
discrete input Real u "Abscissa value";
discrete output Real y "Interpolated value";

external "C" equation
y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
annotation(derivative=Modelica.Blocks.Tables.Internal.getDerTable1DValueNoDer);
end Modelica.Blocks.Tables.Internal.getTable1DValueNoDer2;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DValueNoDer2_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable1DValueNoDer2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmax
discrete input Modelica.Blocks.Types.ExternalCombiTable2D tableID;
discrete output Real uMax[2] "Maximum abscissa value in table";

external "C" equation
ModelicaStandardTables_CombiTable2D_maximumAbscissa(tableID, uMax) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmax;

  */
DYMOLA_STATIC RealArray    Modelica_Blocks_Tables_Internal_getTable2DAbscissaUmax_M
  (struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmax")
  {
    /* Declare outputs and temporaries */
    RealArray    uMax0_0;
    MarkObject retmark_ = PushMark();
    uMax0_0=RealTemporary( 1, 2);
    RePushMark(&retmark_);
    RealFillAssign( uMax0_0, 0);
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable2D_maximumAbscissa)(externalTable_[
        tableID0_0.id_0member].obj_, uMax0_0.data);
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return uMax0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmin
discrete input Modelica.Blocks.Types.ExternalCombiTable2D tableID;
discrete output Real uMin[2] "Minimum abscissa value in table";

external "C" equation
ModelicaStandardTables_CombiTable2D_minimumAbscissa(tableID, uMin) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmin;

  */
DYMOLA_STATIC RealArray    Modelica_Blocks_Tables_Internal_getTable2DAbscissaUmin_M
  (struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmin")
  {
    /* Declare outputs and temporaries */
    RealArray    uMin0_0;
    MarkObject retmark_ = PushMark();
    uMin0_0=RealTemporary( 1, 2);
    RePushMark(&retmark_);
    RealFillAssign( uMin0_0, 0);
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable2D_minimumAbscissa)(externalTable_[
        tableID0_0.id_0member].obj_, uMin0_0.data);
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return uMin0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable2DValueNoDer2
discrete input Modelica.Blocks.Types.ExternalCombiTable2D tableID;
discrete input Real u1 "Value of first independent variable";
discrete input Real u2 "Value of second independent variable";
discrete output Real y "Interpolated value";

external "C" equation
y = ModelicaStandardTables_CombiTable2D_getValue(tableID, u1, u2) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
annotation(derivative=Modelica.Blocks.Tables.Internal.getDerTable2DValueNoDer);
end Modelica.Blocks.Tables.Internal.getTable2DValueNoDer2;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable2DValueNoDer2_M(
  struct DymStruc0 tableID0_0, double  u10_0, double  u20_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable2DValueNoDer2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTable2D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, u10_0, u20_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTimeTableTmax
discrete input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete output Real timeMax "Maximum abscissa value in table";

external "C" equation
timeMax = ModelicaStandardTables_CombiTimeTable_maximumTime(tableID) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTimeTableTmax;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmax_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTimeTableTmax")
  {
    /* Declare outputs and temporaries */
    double   timeMax0_0;
    timeMax0_0=0;
    /* Start of real code */
    {
      timeMax0_0 = (ModelicaStandardTables_CombiTimeTable_maximumTime)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return timeMax0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTimeTableTmin
discrete input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete output Real timeMin "Minimum abscissa value in table";

external "C" equation
timeMin = ModelicaStandardTables_CombiTimeTable_minimumTime(tableID) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTimeTableTmin;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableTmin_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTimeTableTmin")
  {
    /* Declare outputs and temporaries */
    double   timeMin0_0;
    timeMin0_0=0;
    /* Start of real code */
    {
      timeMin0_0 = (ModelicaStandardTables_CombiTimeTable_minimumTime)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return timeMin0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTimeTableValueNoDer2
discrete input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
input Integer icol "Column number";
discrete input Real timeIn "(Scaled) time value";
discrete input Real nextTimeEvent "(Scaled) next time event in table";
discrete input Real pre_nextTimeEvent "Pre-value of (scaled) next time event in table";
discrete output Real y "Interpolated value";

external "C" equation
y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
annotation(derivative(noDerivative=nextTimeEvent, noDerivative=pre_nextTimeEvent)=Modelica.Blocks.Tables.Internal.getDerTimeTableValueNoDer);
end Modelica.Blocks.Tables.Internal.getTimeTableValueNoDer2;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTimeTableValueNoDer2_M
  (struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent) {
  PushContext("Modelica.Blocks.Tables.Internal.getTimeTableValueNoDer2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTimeTable_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, timeIn0_0, nextTimeEvent0_0, 
        prex_0nextTimeEvent);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
input Modelica.Blocks.Types.Extrapolation extrapolation(start = Modelica.Blocks.Types.Extrapolation.LastTwoPoints);
input Boolean verboseRead(start = true) "= true: Print info message; = false: No info message";
discrete output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" equation
externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init2(fileName, tableName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness, extrapolation, verboseRead) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int  extrapolation0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init2)(fileName0_0, tableName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0, extrapolation0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function destructor
discrete input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" equation
ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Modelica.Blocks.Types.Smoothness smoothness;
input Modelica.Blocks.Types.Extrapolation extrapolation(start = Modelica.Blocks.Types.Extrapolation.LastTwoPoints);
input Boolean verboseRead(start = true) "= true: Print info message; = false: No info message";
discrete output Modelica.Blocks.Types.ExternalCombiTable2D externalCombiTable2D;

external "C" equation
externalCombiTable2D = ModelicaStandardTables_CombiTable2D_init2(fileName, tableName, table, size(table, 1), size(table, 2), smoothness, extrapolation, verboseRead) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable2D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, int 
   smoothness0_0, int  extrapolation0_0, int  verboseRead0_0, int id_, int alwaysMakeNew_)
   {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable2D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable2D0_0;
    externalCombiTable2D0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTable2D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable2D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable2D_init2)(fileName0_0, tableName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], smoothness0_0, 
        extrapolation0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable2D0_0;
  }}

/* Flattened Modelica model:

function destructor
discrete input Modelica.Blocks.Types.ExternalCombiTable2D externalCombiTable2D;

external "C" equation
ModelicaStandardTables_CombiTable2D_close(externalCombiTable2D) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable2D_destructor_M(
  void* externalCombiTable2D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable2D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable2D_close)(externalCombiTable2D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
discrete input Real startTime(unit = "s");
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
input Modelica.Blocks.Types.Extrapolation extrapolation;
discrete input Real shiftTime(start = 0.0, unit = "s");
input Modelica.Blocks.Types.TimeEvents timeEvents(start = Modelica.Blocks.Types.TimeEvents.Always);
input Boolean verboseRead(start = true) "= true: Print info message; = false: No info message";
discrete output Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;

external "C" equation
externalCombiTimeTable = ModelicaStandardTables_CombiTimeTable_init2(fileName, tableName, table, size(table, 1), size(table, 2), startTime, columns, size(columns, 1), smoothness, extrapolation, shiftTime, timeEvents, verboseRead) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTimeTable_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  double  startTime0_0, IntegerArray   columns0_0, int  smoothness0_0, int  
  extrapolation0_0, double  shiftTime0_0, int  timeEvents0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTimeTable")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTimeTable0_0;
    externalCombiTimeTable0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTimeTable0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTimeTable_init2)(fileName0_0, tableName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], startTime0_0, 
        columns0_0.data, columns0_0.dims[1-1], smoothness0_0, extrapolation0_0, 
        shiftTime0_0, timeEvents0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTimeTable0_0;
  }}

/* Flattened Modelica model:

function destructor
discrete input Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;

external "C" equation
ModelicaStandardTables_CombiTimeTable_close(externalCombiTimeTable) annotation(Include="#include \"ModelicaStandardTables.h\"", Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, IncludeDirectory="modelica://Modelica/Resources/C-Sources", LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M(
  void* externalCombiTimeTable0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTimeTable.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTimeTable_close)(externalCombiTimeTable0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Math.Vectors.interpolate
discrete input Real x[:] "Abscissa table vector (strict monotonically increasing values required)";
discrete input Real y[size(x, 1)] "Ordinate table vector";
discrete input Real xi "Desired abscissa value";
input Integer iLast(start = 1) "Index used in last search";
discrete output Real yi "Ordinate value corresponding to xi";
output Integer iNew(start = 1) "xi is in the interval x[iNew] <= xi < x[iNew+1]";
protected 
Integer i;
Integer nx(start = size(x, 1));
discrete Real x1;
discrete Real x2;
discrete Real y1;
discrete Real y2;
public 
algorithm 
assert(nx > 0, "The table vectors must have at least 1 entry.");
if (nx == 1) then 
yi := y[1];
else
i := min(max(iLast, 1), nx-1);
if (xi >= x[i]) then 
while i < nx and xi >= x[i] loop
i := i+1;
end while;
i := i-1;
else
while i > 1 and xi < x[i] loop
i := i-1;
end while;
end if;
x1 := x[i];
x2 := x[i+1];
y1 := y[i];
y2 := y[i+1];
assert(x2 > x1, "Abscissa table vector values must be increasing");
yi := y1+(y2-y1)*(xi-x1)/(x2-x1);
iNew := i;
end if;
annotation(smoothOrder=100);
end Modelica.Math.Vectors.interpolate;

  */
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0) {
  PushContext("Modelica.Math.Vectors.interpolate")
  AssertModelica(DYNSizeSimple(y0_0,1)==DYNSizeSimple(x0_0, 1),"size(y, 1) == size(x, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   yi0_0;
    int   iNew0_0;
    int   i0_0;
    int   nx0_0;
    double   x10_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    yi0_0=0;
    iNew0_0 = 1;
    i0_0=0;
    nx0_0 = DYNSizeSimple(x0_0, 1);
    x10_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    /* Start of real code */
      AssertModelica(nx0_0 > 0,"nx > 0", "The table vectors must have at least 1 entry.");
      if (nx0_0 == 1) {
        yi0_0 = RealElement( y0_0, (SizeType)(1));
      }
      else{
        i0_0 = IntegerBmin(IntegerBmax(iLast0_0, 1), nx0_0-1);
        if (xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
          while (i0_0 < nx0_0 AND xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0+1;
          }
          i0_0 = i0_0-1;
        }
        else{
          while (i0_0 > 1 AND xi0_0 < RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0-1;
          }
        }
        x10_0 = RealElement( x0_0, (SizeType)(i0_0));
        x20_0 = RealElement( x0_0, (SizeType)(i0_0+1));
        y10_0 = RealElement( y0_0, (SizeType)(i0_0));
        y20_0 = RealElement( y0_0, (SizeType)(i0_0+1));
        AssertModelica(x20_0 > x10_0,"x2 > x1", "Abscissa table vector values must be increasing");
        yi0_0 = y10_0+divGuarded((y20_0-y10_0)*(xi0_0-x10_0),"(y2-y1)*(xi-x1)",
          x20_0-x10_0,"x2-x1");
        iNew0_0 = i0_0;
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Math_Vectors_interpolate_struct out_;
      out_.yi0_0_0member = yi0_0;
      out_.iNew0_0_0member = iNew0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.isEmpty
input String string;
output Boolean result "True, if string is empty";
protected 
Integer nextIndex;
Integer len;
public 
algorithm 
nextIndex := ModelicaStrings_skipWhiteSpace(string, 1);
len := ModelicaStrings_length(string);
if (len < 1 or nextIndex > len) then 
result := true;
else
result := false;
end if;
end Modelica.Utilities.Strings.isEmpty;

  */
DYMOLA_STATIC int   Modelica_Utilities_Strings_isEmpty(const char*  string0_0) {
  PushContext("Modelica.Utilities.Strings.isEmpty")
  {
    /* Declare outputs and temporaries */
    int   result0_0;
    int   nextIndex0_0;
    int   len0_0;
    result0_0=0;
    nextIndex0_0=0;
    len0_0=0;
    /* Start of real code */
      nextIndex0_0 = ModelicaStrings_skipWhiteSpace(string0_0, 1);
      len0_0 = ModelicaStrings_length(string0_0);
      if (len0_0 < 1 OR nextIndex0_0 > len0_0) {
        result0_0 = true;
      }
      else{
        result0_0 = false;
      }
    /* Output section */
    PopContext()
    return result0_0;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(2)
BreakSectionFunctionDef(3)
#define NX_    12
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    524
#define NWP_   395
#define NP_    209
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   27
#define MAXAuxStrLen_   500
#define NHash1_ 964415676
#define NHash2_ 483722015
#define NHash3_ 0
#define NI_    0
#define NRelF_ 41
#define NRel_  41
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    359
#define SizePre_ 6
#define SizeEq_ 11
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 6
#define NrDymolaTimers_ 0
#define NWhen_ 2
#define NCheckIf_ 0
#define NGlobalHelp_ 90
#define NGlobalHelpI_ 19
#ifndef NExternalObject_
#define NExternalObject_ 7
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="EHPTexamples.SHEV.SHEV_OO";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "C:/Users/Massimo Ceraolo/AppData/Roaming/DassaultSystemes/Dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[20]={5 , 6 , 1 , 2 , 7 , 10 , 11 , 12 , 2 , 3 , 6
   , 1 , 4 , 2 , 5 , 9 , 1 , 8 , 0 , 0};
static int QJacobianGrp0[13]={12, 2, 2, 2, 12, 0, 0, 2, 2, 2, 2, 12, 0};
static int QJacobianGrp1[13]={0, 3, 3, 3, 0, 6, 0, 6, 6, 6, 6, 0, 0};
static int QJacobianGrp2[10]={1, 4 , 6 , 2 , 3 , 4 , 5 , 6 , 8 , 0};
static int QJacobianGrp3[13]={0, 0, 0, 5, 5, 5, 9, 9, 9, 9, 9, 0, 0};
static int QJacobianGrp4[6]={1, 8 , 2 , 4 , 8 , 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[6]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{1, QJacobianGrp2},{0, QJacobianGrp3},{1, 
  QJacobianGrp4},{0,0}};
DYMOLA_STATIC double QJacobianCD_[13]={0  , 44 , 55 , 60 , 63 , 64 , 90 , 110 , 77
   , 96 , 143 , 154 , 165};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
InitialSection
#if defined(DynSimStruct)
DYNX(W_,410) = 0;
DYNX(W_,412) = 0;
DYNX(W_,413) = 0;
DYNX(W_,395) = false;
DYNX(W_,396) = false;
DYNX(W_,397) = false;
DYNX(W_,398) = 3;
DYNX(W_,403) = 0;
DYNX(W_,404) = 0;
#endif

InitialSection
#if defined(DynSimStruct)
DYNX(W_,1) = false;
DYNX(W_,2) = false;
DYNX(W_,3) = false;
DYNX(W_,5) = 3;
DYNX(W_,6) = false;
memcpy(&DYNX(W_,9), &DymArrays0, sizeof(double)*7);
DYNX(W_,19) = 0;
DYNX(W_,20) = 1;
DYNX(W_,27) = false;
DYNX(W_,33) = false;
DYNX(W_,108) = false;
DYNX(W_,111) = false;
DYNX(W_,112) = false;
DYNX(W_,117) = 3;
DYNX(W_,118) = false;
DYNX(W_,138) = false;
DYNX(W_,145) = 1;
DYNX(W_,174) = 1;
DYNX(W_,241) = false;
DYNX(W_,244) = false;
DYNX(W_,245) = false;
DYNX(W_,250) = 3;
DYNX(W_,251) = false;
DYNX(W_,258) = 3;
DYNX(W_,259) = false;
DYNX(W_,331) = false;
DYNX(W_,332) = false;
DYNX(W_,336) = 1;
DYNX(W_,358) = false;
DYNX(W_,359) = false;
DYNX(W_,365) = 1;
DYNX(W_,53) = false;
#endif
DYNSetAuxString(did_, "SHEVmaps.txt", 0);
DYNSetAuxString(did_, "motEffTable", 1);
DYNSetAuxString(did_, "SHEVmaps.txt", 2);
DYNSetAuxString(did_, "motEffTable", 3);
DYNSetAuxString(did_, "motEffTable", 4);
DYNSetAuxString(did_, "SHEVmaps.txt", 5);
#if defined(DynSimStruct)
DYNX(W_,90) = false;
DYNX(W_,91) = false;
DYNX(W_,113) = 3;
DYNX(W_,120) = false;
DYNX(W_,121) = 2;
DYNX(W_,129) = false;
DYNX(W_,130) = 2;
DYNX(W_,136) = 1;
#endif
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
   6);
#if defined(DynSimStruct)
DYNX(W_,142) = false;
DYNX(W_,143) = 2;
#endif
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
   7);
DYNSetAuxString(did_, "optiSpeed", 8);
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
   9);
#if defined(DynSimStruct)
DYNX(W_,172) = false;
DYNX(W_,173) = 2;
#endif
DYNSetAuxString(did_, "maxIceTau", 10);
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
   11);
#if defined(DynSimStruct)
DYNX(W_,182) = false;
DYNX(W_,183) = 2;
#endif
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
   12);
DYNSetAuxString(did_, "gensetDriveEffTable", 13);
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
   14);
DYNSetAuxString(did_, "gensetDriveEffTable", 15);
DYNSetAuxString(did_, "gensetDriveEffTable", 16);
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
   17);
#if defined(DynSimStruct)
DYNX(W_,223) = false;
DYNX(W_,224) = false;
DYNX(W_,246) = 3;
DYNX(W_,253) = false;
DYNX(W_,254) = 2;
#endif
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
   18);
DYNSetAuxString(did_, "specificCons", 19);
DYNSetAuxString(did_, "specificCons", 20);
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
   21);
#if defined(DynSimStruct)
DYNX(W_,333) = 3;
#endif
DYNSetAuxString(did_, "maxIceTau", 22);
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
   23);
#if defined(DynSimStruct)
DYNX(W_,348) = 2;
DYNX(W_,355) = false;
DYNX(W_,356) = 2;
DYNX(W_,360) = 3;
#endif
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/Sort1.txt",
   24);
DYNSetAuxString(did_, "Cycle", 25);
DYNSetAuxString(did_, "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/Sort1.txt",
   26);
#if defined(DynSimStruct)
DYNX(W_,369) = 1;
DYNX(W_,380) = false;
DYNX(W_,381) = 2;
DYNX(W_,383) = false;
DYNX(W_,384) = 2;
DYNX(W_,387) = false;
DYNX(W_,388) = 2;
DYNX(W_,54) = false;
DYNX(W_,82) = 1;
DYNX(W_,83) = 2;
DYNX(W_,84) = false;
DYNX(W_,144) = true;
DYNX(W_,165) = 2;
DYNX(W_,166) = 2;
DYNX(W_,167) = false;
DYNX(W_,175) = true;
DYNX(W_,176) = 1;
DYNX(W_,177) = 2;
DYNX(W_,178) = false;
DYNX(W_,187) = true;
DYNX(W_,215) = 1;
DYNX(W_,216) = 2;
DYNX(W_,217) = false;
DYNX(W_,256) = true;
DYNX(W_,323) = 1;
DYNX(W_,324) = 2;
DYNX(W_,325) = false;
DYNX(W_,349) = 1;
DYNX(W_,350) = 2;
DYNX(W_,351) = false;
DYNX(W_,363) = 3;
DYNX(W_,366) = true;
DYNX(W_,367) = 1;
DYNX(W_,371) = false;
DYNX(W_,7) = 0;
DYNX(W_,21) = 0;
DYNX(W_,55) = 0;
DYNX(W_,4) = 0;
DYNX(W_,101) = 0;
DYNX(W_,0) = 0;
DYNX(W_,389) = 0;
DYNX(W_,234) = 0;
DYNX(W_,139) = 0;
DYNX(W_,188) = 0;
DYNX(W_,137) = 0;
DYNX(W_,261) = 0;
DYNX(W_,122) = 0;
DYNX(W_,100) = 0;
DYNX(W_,391) = 0;
DYNX(W_,233) = 0;
DYNX(W_,124) = 0;
DYNX(W_,115) = 0;
DYNX(W_,119) = 0;
DYNX(W_,248) = 0;
DYNX(W_,252) = 0;
DYNX(W_,260) = 0;
DYNX(W_,335) = 0;
DYNX(W_,362) = 0;
DYNX(W_,30) = 0.0;
DYNX(W_,24) = 0.0;
DYNX(W_,37) = 0.0;
DYNX(W_,31) = 0.0;
DYNX(W_,8) = false;
DYNX(W_,114) = false;
DYNX(W_,106) = 0.0;
DYNX(W_,105) = 0.0;
DYNX(W_,98) = 0.0;
DYNX(W_,97) = 0.0;
DYNX(W_,99) = 0.0;
DYNX(W_,104) = 0.0;
DYNX(W_,103) = 0.0;
DYNX(W_,102) = 0.0;
DYNX(W_,96) = 0.0;
DYNX(W_,107) = 0.0;
DYNX(W_,94) = 0.0;
DYNX(W_,390) = 0.0;
DYNX(W_,394) = 0.0;
DYNX(W_,393) = 0.0;
DYNX(W_,392) = 0.0;
DYNX(W_,247) = false;
DYNX(W_,239) = 0.0;
DYNX(W_,238) = 0.0;
DYNX(W_,231) = 0.0;
DYNX(W_,230) = 0.0;
DYNX(W_,232) = 0.0;
DYNX(W_,237) = 0.0;
DYNX(W_,236) = 0.0;
DYNX(W_,235) = 0.0;
DYNX(W_,229) = 0.0;
DYNX(W_,240) = 0.0;
DYNX(W_,227) = 0.0;
DYNX(W_,334) = false;
DYNX(W_,141) = 0.0;
DYNX(W_,361) = false;
DYNX(W_,123) = 0.0;
DYNX(W_,127) = 0.0;
DYNX(W_,126) = 0.0;
DYNX(W_,125) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,14) >= 0,"battery.SOCMin >= 0", "SOCMin must be greater than, or equal to 0");
AssertModelica(DYNX(DP_,15) <= 1,"battery.SOCMax <= 1", "SOCMax must be smaller than, or equal to 1");
AssertModelica(DYNX(DP_,14) < DYNX(DP_,15),"battery.SOCMin < battery.SOCMax", 
  StringAdd(StringAdd(StringAdd(StringAdd("SOCMax(=",Real2String2(DYNX(DP_,15), 
  true, 0)),") must be greater than SOCMin(="),Real2String2(DYNX(DP_,14), true, 0)),
  ")"));
AssertModelica(DYNX(DP_,16) >= DYNX(DP_,14),"battery.SOCInit >= battery.SOCMin",
   StringAdd(StringAdd(StringAdd(StringAdd("SOCInit(=",Real2String2(DYNX(DP_,16),
   true, 0)),") must be greater than, or equal to SOCMin(="),Real2String2(
  DYNX(DP_,14), true, 0)),")"));
AssertModelica(DYNX(DP_,16) <= DYNX(DP_,15),"battery.SOCInit <= battery.SOCMax",
   StringAdd(StringAdd(StringAdd(StringAdd("SOCInit(=",Real2String2(DYNX(DP_,16),
   true, 0)),") must be smaller than, or equal to SOCMax(="),Real2String2(
  DYNX(DP_,15), true, 0)),")"));
AssertModelica(DYNX(DP_,67) >= DYNX(DP_,68),"genset.limiter.uMax >= genset.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,67), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,68),
   true, 0)),")"));
AssertModelica(DYNX(DP_,92) >= DYNX(DP_,93),"genset.gms.limMinW.uMax >= genset.gms.limMinW.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,92), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,93),
   true, 0)),")"));
AssertModelica(DYNX(DP_,195) >= DYNX(DP_,196),"genset.mbIce.limiter.uMax >= genset.mbIce.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,195), true, 0)),") < uMin (="),Real2String2(
  DYNX(DP_,196), true, 0)),")"));
BoundParameterSection
DYNX(W_,16) = DYNX(DP_,4);
DYNX(W_,17) = 9.80665*DYNX(DP_,9)*DYNX(W_,16);
DYNX(W_,18) = 0.5*DYNX(DP_,7)*DYNX(DP_,8)*DYNX(DP_,10);
DYNX(W_,22) = DYNX(DP_,18);
DYNX(DYNhelp,0) = divinvGuarded(DYNX(W_,22),"battery.R1Cell");
DYNX(W_,23) = DYNX(DYNhelp,0)*60;
DYNX(W_,40) = divGuarded(DYNX(DP_,11),"battery.QCellNom",DYNX(DP_,13)-
  DYNX(DP_,12),"battery.ECellMax-battery.ECellMin");
DYNX(DYNhelp,1) = divinvGuarded(DYNX(DP_,21),"battery.ns");
DYNX(W_,46) = DYNX(DYNhelp,1)*DYNX(W_,40)*DYNX(DP_,22);
DYNX(W_,25) = DYNX(W_,46);
DYNX(DYNhelp,2) = divinvGuarded(DYNX(DP_,22),"battery.np");
DYNX(W_,47) = DYNX(DYNhelp,2)*DYNX(DP_,18)*DYNX(DP_,21);
DYNX(W_,26) = DYNX(W_,47);
DYNX(W_,28) = DYNX(DP_,23);
AssertModelica(1+DYNX(DP_,24)*(DYNX(W_,28)-DYNX(DP_,23)) >= 1E-15,
  "1+battery.R0.alpha*(battery.R0.T_heatPort-battery.R0.T_ref) >= 1E-15", 
  "Temperature outside scope of model!");
DYNX(W_,48) = DYNX(DYNhelp,2)*DYNX(W_,22)*DYNX(DP_,21);
DYNX(W_,32) = DYNX(W_,48);
DYNX(W_,34) = DYNX(DP_,25);
AssertModelica(1+DYNX(DP_,26)*(DYNX(W_,34)-DYNX(DP_,25)) >= 1E-15,
  "1+battery.R1.alpha*(battery.R1.T_heatPort-battery.R1.T_ref) >= 1E-15", 
  "Temperature outside scope of model!");
DYNX(W_,51) = DYNX(DYNhelp,1)*DYNX(W_,23)*DYNX(DP_,22);
DYNX(W_,36) = DYNX(W_,51);
DYNX(W_,38) = DYNX(W_,51)/(double)(10000);
DYNX(W_,50) = DYNX(DP_,18)+DYNX(W_,22);
DYNX(W_,39) = divGuarded(DYNX(DP_,12)+DYNX(DP_,13)-2.0*DYNX(W_,50)*DYNX(DP_,20),
  "battery.ECellMin+battery.ECellMax-2.0*(battery.RtotCell*battery.iCellEfficiency)",
  DYNX(DP_,12)+DYNX(DP_,13)+2.0*DYNX(W_,50)*DYNX(DP_,20),"battery.ECellMin+battery.ECellMax+2.0*(battery.RtotCell*battery.iCellEfficiency)");
AssertModelica(DYNX(DP_,19) <= DYNX(W_,39),"battery.efficiency <= battery.efficiencyMax",
   StringAdd(StringAdd("Charging/discharging energy efficiency too big with respect to the actual serial resistance (Max allowed =",
  Real2String2(DYNX(W_,39), true, 0)),")"));
DYNX(W_,44) = DYNX(DP_,13)*DYNX(DP_,21);
DYNX(W_,43) = DYNX(DP_,12)*DYNX(DP_,21);
DYNX(W_,49) = DYNX(W_,47)+DYNX(W_,48);
DYNX(W_,41) = divGuarded((1-DYNX(DP_,19))*(DYNX(W_,44)+DYNX(W_,43))-(2+2*
  DYNX(DP_,19))*DYNX(W_,49)*DYNX(DP_,20),"(1-battery.efficiency)*(battery.EBatteryMax+battery.EBatteryMin)-(2+2*battery.efficiency)*battery.Rtot*battery.iCellEfficiency",
  (1+DYNX(DP_,19))*(DYNX(W_,44)+DYNX(W_,43))-2.0*(1-DYNX(DP_,19))*DYNX(W_,49)*
  DYNX(DP_,20),"(1+battery.efficiency)*(battery.EBatteryMax+battery.EBatteryMin)-2.0*((1-battery.efficiency)*battery.Rtot*battery.iCellEfficiency)");
DYNX(W_,42) = DYNX(DP_,17)*DYNX(DP_,22);
DYNX(W_,45) = DYNX(DP_,11)*DYNX(DP_,22);
DYNX(W_,52) = DYNX(W_,41);
DYNX(W_,56) = DYNX(DP_,27);
DYNX(W_,57) = DYNX(DP_,28);
DYNX(W_,58) = DYNX(DP_,30);
DYNX(W_,59) = DYNX(W_,54);
DYNX(W_,60) = DYNX(DP_,28);
DYNX(W_,61) = DYNX(DP_,27);
DYNX(W_,62) = DYNX(DP_,30);
DYNX(W_,63) = DYNX(DP_,32);
DYNX(W_,64) = DYNX(DP_,33);
DYNX(W_,65) = DYNX(DP_,34);
DYNX(W_,66) = DYNX(DP_,35);
DYNX(W_,67) = DYNX(DP_,36);
DYNX(W_,68) = DYNX(DP_,37);
DYNX(W_,69) = DYNX(DP_,38);
DYNX(W_,70) = DYNX(DP_,39);
DYNX(W_,71) = DYNX(DP_,40);
DYNX(W_,72) = DYNX(W_,59);
DYNX(W_,73) = DYNX(W_,63);
DYNX(W_,74) = DYNX(W_,64);
DYNX(W_,75) = DYNX(W_,65);
DYNX(W_,76) = DYNX(W_,66);
DYNX(W_,77) = DYNX(W_,67);
DYNX(W_,78) = DYNX(W_,68);
DYNX(W_,79) = DYNX(W_,69);
DYNX(W_,80) = DYNX(W_,70);
DYNX(W_,81) = DYNX(W_,71);
InitialBoundSection
DYNX(DYNhelp,3) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(drive.toElePow.toEff.fileName)")
  Modelica_Utilities_Strings_isEmpty("SHEVmaps.txt"));
PopModelContext();
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable2D((if drive.toElePow.toEff.tableOnFile then drive.toElePow.toEff.tableName else \"NoName\"), (if drive.toElePow.toEff.tableOnFile and drive.toElePow.toEff.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(drive.toElePow.toEff.fileName) then drive.toElePow.toEff.fileName else \"NoName\"), drive.toElePow.toEff.table, drive.toElePow.toEff.smoothn...")
    Modelica_Blocks_Types_ExternalCombiTable2D_M(IF DYNX(W_,72) THEN 
    "motEffTable" ELSE "NoName", IF DYNX(W_,72) AND (strcmp("SHEVmaps.txt", 
    "NoName")!=0) AND  NOT DYNX(DYNhelp,3) THEN "SHEVmaps.txt" ELSE "NoName", 
    RealTemporaryDense( &DYNX(W_,73), 2, 3, 3), (Integer)(DYNX(W_,82)), 
    (Integer)(DYNX(W_,83)), (Integer)(IF DYNX(W_,72) THEN DYNX(DP_,42) ELSE 
    false), 0, 1));
  DYNX(W_,89) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
RealAssign (RealTemporaryDense( &DYNX(W_,85), 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmin(\ndrive.toElePow.toEff.tableID)")
  Modelica_Blocks_Tables_Internal_getTable2DAbscissaUmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,89))))));
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,87), 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmax(\ndrive.toElePow.toEff.tableID)")
  Modelica_Blocks_Tables_Internal_getTable2DAbscissaUmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,89))))));
PopAllMarks();
DYNX(DYNhelp,4) = divinvGuarded(DYNX(W_,60),"drive.toElePow.tauMax");
DYNX(W_,92) = DYNX(DYNhelp,4);
DYNX(DYNhelp,5) = divinvGuarded(DYNX(W_,62),"drive.toElePow.wMax");
DYNX(W_,93) = DYNX(DYNhelp,5);
DYNX(W_,95) = DYNX(DP_,29);
DYNX(W_,109) = DYNX(DP_,44);
AssertModelica(1+DYNX(DP_,45)*(DYNX(W_,109)-DYNX(DP_,44)) >= 1E-15,
  "1+drive.constPDC.varCond.alpha*(drive.constPDC.varCond.T_heatPort-drive.constPDC.varCond.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(DYNhelp,6) = sqr(DYNX(W_,95));
DYNX(DYNhelp,7) = divinvGuarded(DYNX(DYNhelp,6),"drive.constPDC.vNom^2");
DYNX(DYNhelp,8) = divinvGuarded(DYNX(DP_,43),"drive.constPDC.Ti");
BreakSectionFunctionCallNew(2);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
DYNX(W_,110) = DYNX(DYNhelp,8)*DYNX(DYNhelp,7);
DYNX(W_,116) = DYNX(DP_,31);
DYNX(W_,128) = DYNX(DP_,53);
AssertModelica(DYNX(W_,128) >= DYNX(DP_,55),"ems.limiter.uMax >= ems.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,128), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,55),
   true, 0)),")"));
DYNX(W_,131) = DYNX(DP_,54);
DYNX(W_,132) = DYNX(DP_,52);
DYNX(W_,133) = DYNX(DP_,50);
DYNX(W_,134) = DYNX(DP_,51);
AssertModelica(DYNX(W_,134) > DYNX(W_,133),"ems.powHyst.uHigh > ems.powHyst.uLow",
   "Hysteresis limits wrong (uHigh <= uLow)");
DYNX(W_,135) = DYNX(DP_,49);
DYNX(W_,140) = DYNX(DP_,62);
DYNX(W_,146) = DYNX(W_,144);
DYNX(W_,147) = DYNX(DP_,71);
DYNX(W_,148) = DYNX(DP_,72);
DYNX(W_,149) = DYNX(DP_,73);
DYNX(W_,150) = DYNX(DP_,74);
DYNX(W_,151) = DYNX(DP_,75);
DYNX(W_,152) = DYNX(DP_,76);
DYNX(W_,153) = DYNX(DP_,77);
DYNX(W_,154) = DYNX(DP_,78);
DYNX(W_,155) = DYNX(DP_,79);
DYNX(W_,156) = DYNX(DP_,80);
DYNX(W_,157) = DYNX(DP_,81);
DYNX(W_,158) = DYNX(DP_,82);
DYNX(W_,159) = DYNX(DP_,83);
DYNX(W_,160) = DYNX(DP_,84);
DYNX(W_,161) = DYNX(DP_,85);
DYNX(W_,162) = DYNX(DP_,86);
DYNX(W_,163) = DYNX(DP_,87);
DYNX(W_,164) = DYNX(DP_,88);
InitialBoundSection
DYNX(DYNhelp,9) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(genset.gms.optiSpeed.fileName)")
  Modelica_Utilities_Strings_isEmpty("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt"));
PopModelContext();
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D((if genset.gms.optiSpeed.tableOnFile then genset.gms.optiSpeed.tableName else \"NoName\"), (if genset.gms.optiSpeed.tableOnFile and genset.gms.optiSpeed.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(genset.gms.optiSpeed.fileName) then genset.gms.optiSpeed.fileName else \"NoName\"), genset.gms.optiSpeed.table, genset.gms.optiSpeed.columns...")
    Modelica_Blocks_Types_ExternalCombiTable1D_M(IF DYNX(W_,146) THEN 
    "optiSpeed" ELSE "NoName", IF DYNX(W_,146) AND (strcmp("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
     "NoName")!=0) AND  NOT DYNX(DYNhelp,9) THEN "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt"
     ELSE "NoName", RealTemporaryDense( &DYNX(W_,147), 2, 9, 2), 
    IntegerTemporaryDense( &DYNX(DP_,90), 1, 1), (Integer)(DYNX(W_,165)), 
    (Integer)(DYNX(W_,166)), (Integer)(IF DYNX(W_,146) THEN DYNX(DP_,89) ELSE 
    false), 1, 1));
  DYNX(W_,170) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
DYNX(W_,168) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin(\ngenset.gms.optiSpeed.tableID)")
  Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,170)))));
PopModelContext();
DYNX(W_,169) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax(\ngenset.gms.optiSpeed.tableID)")
  Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,170)))));
PopModelContext();
DYNX(W_,171) = DYNX(DP_,70);
InitialBoundSection
DYNX(DYNhelp,10) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(genset.gms.maxTau.fileName)")
  Modelica_Utilities_Strings_isEmpty("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt"));
PopModelContext();
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D((if genset.gms.maxTau.tableOnFile then genset.gms.maxTau.tableName else \"NoName\"), (if genset.gms.maxTau.tableOnFile and genset.gms.maxTau.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(genset.gms.maxTau.fileName) then genset.gms.maxTau.fileName else \"NoName\"), genset.gms.maxTau.table, genset.gms.maxTau.columns, genset.gms.maxTau.smoo...")
    Modelica_Blocks_Types_ExternalCombiTable1D_M(IF DYNX(W_,175) THEN 
    "maxIceTau" ELSE "NoName", IF DYNX(W_,175) AND (strcmp("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
     "NoName")!=0) AND  NOT DYNX(DYNhelp,10) THEN "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt"
     ELSE "NoName", RealTemporaryDense( (Real*)(0), 2, 0, 2), IntegerTemporaryDense( 
    &DYNX(DP_,95), 1, 1), (Integer)(DYNX(W_,176)), (Integer)(DYNX(W_,177)), 
    (Integer)(IF DYNX(W_,175) THEN DYNX(DP_,94) ELSE false), 2, 1));
  DYNX(W_,181) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
DYNX(W_,179) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin(\ngenset.gms.maxTau.tableID)")
  Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,181)))));
PopModelContext();
DYNX(W_,180) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax(\ngenset.gms.maxTau.tableID)")
  Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,181)))));
PopModelContext();
DYNX(W_,184) = DYNX(DP_,65);
DYNX(W_,185) = DYNX(DP_,64);
DYNX(W_,186) = DYNX(DP_,63);
DYNX(W_,189) = DYNX(W_,184);
DYNX(W_,190) = DYNX(W_,185);
DYNX(W_,191) = DYNX(W_,186);
DYNX(W_,192) = DYNX(W_,187);
DYNX(W_,193) = DYNX(W_,185);
DYNX(W_,194) = DYNX(W_,184);
DYNX(W_,195) = DYNX(W_,186);
DYNX(W_,196) = DYNX(DP_,100);
DYNX(W_,197) = DYNX(DP_,101);
DYNX(W_,198) = DYNX(DP_,102);
DYNX(W_,199) = DYNX(DP_,103);
DYNX(W_,200) = DYNX(DP_,104);
DYNX(W_,201) = DYNX(DP_,105);
DYNX(W_,202) = DYNX(DP_,106);
DYNX(W_,203) = DYNX(DP_,107);
DYNX(W_,204) = DYNX(DP_,108);
DYNX(W_,205) = DYNX(W_,192);
DYNX(W_,206) = DYNX(W_,196);
DYNX(W_,207) = DYNX(W_,197);
DYNX(W_,208) = DYNX(W_,198);
DYNX(W_,209) = DYNX(W_,199);
DYNX(W_,210) = DYNX(W_,200);
DYNX(W_,211) = DYNX(W_,201);
DYNX(W_,212) = DYNX(W_,202);
DYNX(W_,213) = DYNX(W_,203);
DYNX(W_,214) = DYNX(W_,204);
InitialBoundSection
DYNX(DYNhelp,11) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(genset.gen.toElePow.toEff.fileName)")
  Modelica_Utilities_Strings_isEmpty("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt"));
PopModelContext();
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable2D((if genset.gen.toElePow.toEff.tableOnFile then genset.gen.toElePow.toEff.tableName else \"NoName\"), (if genset.gen.toElePow.toEff.tableOnFile and genset.gen.toElePow.toEff.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(genset.gen.toElePow.toEff.fileName) then genset.gen.toElePow.toEff.fileName else \"NoName\"), genset.gen.toElePow.toEff....")
    Modelica_Blocks_Types_ExternalCombiTable2D_M(IF DYNX(W_,205) THEN 
    "gensetDriveEffTable" ELSE "NoName", IF DYNX(W_,205) AND (strcmp(
    "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
     "NoName")!=0) AND  NOT DYNX(DYNhelp,11) THEN "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt"
     ELSE "NoName", RealTemporaryDense( &DYNX(W_,206), 2, 3, 3), (Integer)(
    DYNX(W_,215)), (Integer)(DYNX(W_,216)), (Integer)(IF DYNX(W_,205) THEN 
    DYNX(DP_,110) ELSE false), 3, 1));
  DYNX(W_,222) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
RealAssign (RealTemporaryDense( &DYNX(W_,218), 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmin(\ngenset.gen.toElePow.toEff.tableID)")
  Modelica_Blocks_Tables_Internal_getTable2DAbscissaUmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,222))))));
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,220), 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmax(\ngenset.gen.toElePow.toEff.tableID)")
  Modelica_Blocks_Tables_Internal_getTable2DAbscissaUmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,222))))));
PopAllMarks();
DYNX(DYNhelp,12) = divinvGuarded(DYNX(W_,193),"genset.gen.toElePow.tauMax");
DYNX(W_,225) = DYNX(DYNhelp,12);
DYNX(DYNhelp,13) = divinvGuarded(DYNX(W_,195),"genset.gen.toElePow.wMax");
DYNX(W_,226) = DYNX(DYNhelp,13);
DYNX(W_,228) = DYNX(DP_,98);
DYNX(W_,242) = DYNX(DP_,112);
AssertModelica(1+DYNX(DP_,113)*(DYNX(W_,242)-DYNX(DP_,112)) >= 1E-15,
  "1+genset.gen.constPDC.varCond.alpha*(genset.gen.constPDC.varCond.T_heatPort-genset.gen.constPDC.varCond.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(DYNhelp,14) = sqr(DYNX(W_,228));
DYNX(DYNhelp,15) = divinvGuarded(DYNX(DYNhelp,14),"genset.gen.constPDC.vNom^2");
DYNX(DYNhelp,16) = divinvGuarded(DYNX(DP_,111),"genset.gen.constPDC.Ti");
DYNX(W_,243) = DYNX(DYNhelp,16)*DYNX(DYNhelp,15);
DYNX(W_,249) = DYNX(DP_,99);
DYNX(W_,255) = DYNX(DP_,66);
DYNX(W_,257) = DYNX(DP_,118);
DYNX(W_,262) = DYNX(W_,256);
DYNX(W_,263) = DYNX(DP_,129);
DYNX(W_,264) = DYNX(DP_,130);
DYNX(W_,265) = DYNX(DP_,131);
DYNX(W_,266) = DYNX(DP_,132);
DYNX(W_,267) = DYNX(DP_,133);
DYNX(W_,268) = DYNX(DP_,134);
DYNX(W_,269) = DYNX(DP_,135);
DYNX(W_,270) = DYNX(DP_,136);
DYNX(W_,271) = DYNX(DP_,137);
DYNX(W_,272) = DYNX(DP_,138);
DYNX(W_,273) = DYNX(DP_,139);
DYNX(W_,274) = DYNX(DP_,140);
DYNX(W_,275) = DYNX(DP_,141);
DYNX(W_,276) = DYNX(DP_,142);
DYNX(W_,277) = DYNX(DP_,143);
DYNX(W_,278) = DYNX(DP_,144);
DYNX(W_,279) = DYNX(DP_,145);
DYNX(W_,280) = DYNX(DP_,146);
DYNX(W_,281) = DYNX(DP_,147);
DYNX(W_,282) = DYNX(DP_,148);
DYNX(W_,283) = DYNX(DP_,149);
DYNX(W_,284) = DYNX(DP_,150);
DYNX(W_,285) = DYNX(DP_,151);
DYNX(W_,286) = DYNX(DP_,152);
DYNX(W_,287) = DYNX(DP_,153);
DYNX(W_,288) = DYNX(DP_,154);
DYNX(W_,289) = DYNX(DP_,155);
DYNX(W_,290) = DYNX(DP_,156);
DYNX(W_,291) = DYNX(DP_,157);
DYNX(W_,292) = DYNX(DP_,158);
DYNX(W_,293) = DYNX(DP_,159);
DYNX(W_,294) = DYNX(DP_,160);
DYNX(W_,295) = DYNX(DP_,161);
DYNX(W_,296) = DYNX(DP_,162);
DYNX(W_,297) = DYNX(DP_,163);
DYNX(W_,298) = DYNX(DP_,164);
DYNX(W_,299) = DYNX(DP_,165);
DYNX(W_,300) = DYNX(DP_,166);
DYNX(W_,301) = DYNX(DP_,167);
DYNX(W_,302) = DYNX(DP_,168);
DYNX(W_,303) = DYNX(DP_,169);
DYNX(W_,304) = DYNX(DP_,170);
DYNX(W_,305) = DYNX(DP_,171);
DYNX(W_,306) = DYNX(DP_,172);
DYNX(W_,307) = DYNX(DP_,173);
DYNX(W_,308) = DYNX(DP_,174);
DYNX(W_,309) = DYNX(DP_,175);
DYNX(W_,310) = DYNX(DP_,176);
DYNX(W_,311) = DYNX(DP_,177);
DYNX(W_,312) = DYNX(DP_,178);
DYNX(W_,313) = DYNX(DP_,179);
DYNX(W_,314) = DYNX(DP_,180);
DYNX(W_,315) = DYNX(DP_,181);
DYNX(W_,316) = DYNX(DP_,182);
DYNX(W_,317) = DYNX(DP_,183);
DYNX(W_,318) = DYNX(DP_,184);
DYNX(W_,319) = DYNX(DP_,185);
DYNX(W_,320) = DYNX(DP_,186);
DYNX(W_,321) = DYNX(DP_,187);
DYNX(W_,322) = DYNX(DP_,188);
InitialBoundSection
DYNX(DYNhelp,17) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(genset.mbIce.toGramsPerkWh.fileName)")
  Modelica_Utilities_Strings_isEmpty("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt"));
PopModelContext();
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable2D((if genset.mbIce.toGramsPerkWh.tableOnFile then genset.mbIce.toGramsPerkWh.tableName else \"NoName\"), (if genset.mbIce.toGramsPerkWh.tableOnFile and genset.mbIce.toGramsPerkWh.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(genset.mbIce.toGramsPerkWh.fileName) then genset.mbIce.toGramsPerkWh.fileName else \"NoName\"), genset.mbIce.toGrams...")
    Modelica_Blocks_Types_ExternalCombiTable2D_M(IF DYNX(W_,262) THEN 
    "specificCons" ELSE "NoName", IF DYNX(W_,262) AND (strcmp("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
     "NoName")!=0) AND  NOT DYNX(DYNhelp,17) THEN "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt"
     ELSE "NoName", RealTemporaryDense( &DYNX(W_,263), 2, 10, 6), (Integer)(
    DYNX(W_,323)), (Integer)(DYNX(W_,324)), (Integer)(IF DYNX(W_,262) THEN 
    DYNX(DP_,189) ELSE false), 4, 1));
  DYNX(W_,330) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
RealAssign (RealTemporaryDense( &DYNX(W_,326), 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmin(\ngenset.mbIce.toGramsPerkWh.tableID)")
  Modelica_Blocks_Tables_Internal_getTable2DAbscissaUmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,330))))));
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,328), 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Tables.Internal.getTable2DAbscissaUmax(\ngenset.mbIce.toGramsPerkWh.tableID)")
  Modelica_Blocks_Tables_Internal_getTable2DAbscissaUmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,330))))));
PopAllMarks();
DYNX(W_,337) = DYNX(W_,256);
DYNX(W_,338) = DYNX(DP_,119);
DYNX(W_,339) = DYNX(DP_,120);
DYNX(W_,340) = DYNX(DP_,121);
DYNX(W_,341) = DYNX(DP_,122);
DYNX(W_,342) = DYNX(DP_,123);
DYNX(W_,343) = DYNX(DP_,124);
DYNX(W_,344) = DYNX(DP_,125);
DYNX(W_,345) = DYNX(DP_,126);
DYNX(W_,346) = DYNX(DP_,127);
DYNX(W_,347) = DYNX(DP_,128);
InitialBoundSection
DYNX(DYNhelp,18) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(genset.mbIce.toLimTau.fileName)")
  Modelica_Utilities_Strings_isEmpty("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt"));
PopModelContext();
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D((if genset.mbIce.toLimTau.tableOnFile then genset.mbIce.toLimTau.tableName else \"NoName\"), (if genset.mbIce.toLimTau.tableOnFile and genset.mbIce.toLimTau.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(genset.mbIce.toLimTau.fileName) then genset.mbIce.toLimTau.fileName else \"NoName\"), genset.mbIce.toLimTau.table, genset.mbIce.toLimTau...")
    Modelica_Blocks_Types_ExternalCombiTable1D_M(IF DYNX(W_,337) THEN 
    "maxIceTau" ELSE "NoName", IF DYNX(W_,337) AND (strcmp("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt",
     "NoName")!=0) AND  NOT DYNX(DYNhelp,18) THEN "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/SHEVmaps.txt"
     ELSE "NoName", RealTemporaryDense( &DYNX(W_,338), 2, 5, 2), 
    IntegerTemporaryDense( &DYNX(W_,348), 1, 1), (Integer)(DYNX(W_,349)), 
    (Integer)(DYNX(W_,350)), (Integer)(IF DYNX(W_,337) THEN DYNX(DP_,194) ELSE 
    false), 5, 1));
  DYNX(W_,354) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
DYNX(W_,352) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin(\ngenset.mbIce.toLimTau.tableID)")
  Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,354)))));
PopModelContext();
DYNX(W_,353) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax(\ngenset.mbIce.toLimTau.tableID)")
  Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,354)))));
PopModelContext();
DYNX(W_,357) = (-0.9)*DYNX(DP_,62);
DYNX(W_,368) = DYNX(W_,363);
DYNX(W_,370) = DYNX(DP_,205);
InitialBoundSection
DYNX(DYNhelp,19) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(driver.driveCyc.fileName)")
  Modelica_Utilities_Strings_isEmpty("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/Sort1.txt"));
PopModelContext();
DYNX(DYNhelp,20) = divinvGuarded(DYNX(W_,369),"driver.driveCyc.timeScale");
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTimeTable((if driver.driveCyc.tableOnFile then driver.driveCyc.tableName else \"NoName\"), (if driver.driveCyc.tableOnFile and driver.driveCyc.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(driver.driveCyc.fileName) then driver.driveCyc.fileName else \"NoName\"), driver.driveCyc.table, driver.driveCyc.startTime/driver.driveCyc.timeScale, driver.d...")
    Modelica_Blocks_Types_ExternalCombiTimeTable_M(IF DYNX(W_,366) THEN "Cycle"
     ELSE "NoName", IF DYNX(W_,366) AND (strcmp("D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/Sort1.txt",
     "NoName")!=0) AND  NOT DYNX(DYNhelp,19) THEN "D:/OneDrive - University of Pisa/2_MODELICA/GITHUB LINKED/EHPTexamples/EHPTexamples/Resources/Sort1.txt"
     ELSE "NoName", RealTemporaryDense( (Real*)(0), 2, 0, 2), DYNX(DYNhelp,20)*
    DYNX(DP_,205), IntegerTemporaryDense( &DYNX(DP_,203), 1, 1), (Integer)(
    DYNX(W_,367)), (Integer)(DYNX(W_,368)), DYNX(DYNhelp,20)*DYNX(W_,370), 
    (Integer)(IF DYNX(W_,367) == 1 THEN DYNX(DP_,206) ELSE IF DYNX(W_,367) == 3
     THEN 1 ELSE 3), (Integer)(IF DYNX(W_,366) THEN DYNX(DP_,202) ELSE false), 6,
     1));
  DYNX(W_,377) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
DYNX(W_,374) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableTmin(\ndriver.driveCyc.tableID)")
  Modelica_Blocks_Tables_Internal_getTimeTableTmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,377)))));
PopModelContext();
DYNX(W_,372) = DYNX(W_,374)*DYNX(W_,369);
DYNX(W_,375) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableTmax(\ndriver.driveCyc.tableID)")
  Modelica_Blocks_Tables_Internal_getTimeTableTmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,377)))));
PopModelContext();
DYNX(W_,373) = DYNX(W_,375)*DYNX(W_,369);
DYNX(W_,376) = DYNX(DP_,204);
DYNX(W_,378) = DYNX(DP_,200);
DYNX(W_,379) = DYNX(DP_,201);
AssertModelica(DYNX(W_,379) >= DYNX(DP_,207),"driver.limAcc.uMax >= driver.limAcc.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,379), true, 0)),") < uMin (="),Real2String2(DYNX(DP_,207),
   true, 0)),")"));
DYNX(W_,382) =  -DYNX(DP_,201);
AssertModelica(DYNX(DP_,208) >= DYNX(W_,382),"driver.limBrak.uMax >= driver.limBrak.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(DP_,208), true, 0)),") < uMin (="),Real2String2(DYNX(W_,382),
   true, 0)),")"));
DYNX(W_,385) = DYNX(DP_,201);
DYNX(W_,386) =  -DYNX(W_,385);
AssertModelica(DYNX(W_,385) >= DYNX(W_,386),"driver.limiter1.uMax >= driver.limiter1.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,385), true, 0)),") < uMin (="),Real2String2(DYNX(W_,386),
   true, 0)),")"));
BoundParameterConstantSection
DYNX(W_,29) = DYNX(W_,26)*(1+DYNX(DP_,24)*(DYNX(W_,28)-DYNX(DP_,23)));
DYNX(W_,35) = DYNX(W_,32)*(1+DYNX(DP_,26)*(DYNX(W_,34)-DYNX(DP_,25)));
BoundParameterSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,435) = DYNX(W_,43)+DYNX(DP_,16)*(DYNX(W_,44)-DYNX(W_,43));
DYNX(W_,504) = DYNX(W_,255);
DYNX(X_,1) = DYNX(W_,43)+DYNX(DP_,16)*(DYNX(W_,44)-DYNX(W_,43));
DYNX(X_,3) = DYNX(W_,43)+DYNX(DP_,16)*(DYNX(W_,44)-DYNX(W_,43));
DYNX(X_,4) = DYNX(DP_,46);
DYNX(X_,5) = DYNX(DP_,61);
DYNX(X_,7) = DYNX(DP_,114);
DYNX(X_,9) = DYNX(DP_,192);
DYNX(X_,10) = DYNX(DP_,199);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,0) = DYNX(W_,398);
DYNX(Aux_,1) = DYNX(W_,396);
DYNX(Aux_,2) = DYNX(W_,395);
DYNX(Aux_,4) = DYNX(W_,404);
DYNX(Aux_,3) = DYNX(W_,403);
DYNX(Aux_,5) = DYNX(W_,401);
InitialSection
InitialSection2
DYNX(W_,364) = false;
 /* Linear system of equations to solve. */
DYNX(F_,0) = 0.0;
SolveScalarLinearParametric(DYNX(DP_,2),"wheel.radius", DYNX(W_,412),
  "der(powProp.flange_a.s)", DYNX(F_,0),"der(wheel.flangeR.phi)");
 /* End of Equation Block */ 

DYNX(W_,457) = DYNX(DP_,3)*DYNX(F_,0);
DYNX(W_,516) = DYNTime;
InitialBoundSection
DYNX(W_,404) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getNextTimeEvent(\ndriver.driveCyc.tableID, \ndriver.driveCyc.timeScaled)")
  Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(DymStruc0_construct(
  (Integer)(DYNX(W_,377))), DYNX(W_,516)));
PopModelContext();
InitialSection2
DYNX(W_,403) = IF Less(DYNX(W_,404),"driver.driveCyc.nextTimeEventScaled", 1E+60,
  "1E+60", 0) THEN DYNX(W_,404) ELSE 1E+60;
DYNX(W_,435) = DYNX(W_,43)+DYNX(DP_,16)*(DYNX(W_,44)-DYNX(W_,43));
DYNX(X_,1) = DYNX(W_,435);
DYNX(W_,504) = DYNX(W_,255);
 /* Linear system of equations to solve. */
DYNX(X_,8) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,140)," -genset.idealGear.ratio",  -
  DYNX(W_,504)," -der(genset.speedSensor.flange.phi)", DYNX(X_,8),
  "genset.gen.inertia.w");
 /* End of Equation Block */ 

DYNX(X_,7) = DYNX(DP_,114);
DYNX(X_,4) = DYNX(DP_,46);
DYNX(X_,3) = DYNX(W_,43)+DYNX(DP_,16)*(DYNX(W_,44)-DYNX(W_,43));
DYNX(X_,5) = DYNX(DP_,61);
DYNX(X_,9) = DYNX(DP_,192);
DYNX(X_,10) = DYNX(DP_,199);
InitialBoundSection
DYNX(Aux_,5) = DYNX(DP_,58);
InitialSection2
DYNX(W_,514) = DYNX(W_,376)+(PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableValueNoDer2(\ndriver.driveCyc.tableID, \n1, \ndriver.driveCyc.timeScaled, \ndriver.driveCyc.nextTimeEventScaled, \ndriver.driveCyc.nextTimeEventScaled_.start)")
  Modelica_Blocks_Tables_Internal_getTimeTableValueNoDer2_M(DymStruc0_construct(
  (Integer)(DYNX(W_,377))), 1, DYNX(W_,516), DYNX(W_,404), DYNX(Aux_,4)));
PopModelContext();
DYNX(W_,515) = 0.2777777777777778*DYNX(W_,514);
DYNX(W_,517) = DYNX(W_,515)-DYNX(W_,412);
DYNX(W_,518) = DYNX(W_,378)*DYNX(W_,517);
DYNX(W_,460) = homotopy(IF GreaterS(DYNX(W_,518),"driver.limiter1.u", 
  DYNX(W_,385),"driver.limiter1.uMax", 1) THEN DYNX(W_,385) ELSE IF LessS(
  DYNX(W_,518),"driver.limiter1.u", DYNX(W_,386),"driver.limiter1.uMin", 2)
   THEN DYNX(W_,386) ELSE DYNX(W_,518), DYNX(W_,518));
DYNX(W_,439) = DYNX(W_,457);
DYNX(W_,400) = PRE(DYNX(W_,400), 3);
DYNX(W_,440) = 0.0;
  if (Less(DYNX(W_,439),"drive.limTau.w", divGuarded(DYNX(W_,56),
    "drive.limTau.powMax",DYNX(W_,57),"drive.limTau.tauMax"),"drive.limTau.powMax/drive.limTau.tauMax",
     3)) {
    DYNX(W_,400) = 0;
    DYNX(W_,440) = DYNX(W_,57);
  }
  else{
    DYNX(W_,400) = 1;
    DYNX(W_,440) = divGuarded(DYNX(W_,56),"drive.limTau.powMax",DYNX(W_,439),
      "drive.limTau.w");
  }
  if (Greater(DYNX(W_,439),"drive.limTau.w", DYNX(W_,58),"drive.limTau.wMax", 4))
     {
    if (Less(DYNX(W_,439),"drive.limTau.w", (1+DYNX(DP_,41))*DYNX(W_,58),
      "(1+drive.limTau.alpha)*drive.limTau.wMax", 5)) {
      DYNX(W_,400) = 2;
      DYNX(W_,440) = divGuarded(DYNX(W_,56)*(1-divGuarded(DYNX(W_,439)-
        DYNX(W_,58),"drive.limTau.w-drive.limTau.wMax",DYNX(DP_,41)*DYNX(W_,58),
        "drive.limTau.alpha*drive.limTau.wMax")),"drive.limTau.powMax*(1-(drive.limTau.w-drive.limTau.wMax)/(drive.limTau.alpha*drive.limTau.wMax))",
        DYNX(W_,58),"drive.limTau.wMax");
    }
    else{
      DYNX(W_,400) = 3;
      DYNX(W_,440) = 0;
    }
  }
  DYNX(W_,441) =  -DYNX(W_,440);
AssertModelica(GreaterEqual(DYNX(W_,440),"drive.variableLimiter.limit1", 
  DYNX(W_,441),"drive.variableLimiter.limit2", 6),"drive.variableLimiter.limit1 >= drive.variableLimiter.limit2",
   "Input signals are not consistent: limit1 < limit2");
DYNX(W_,444) = homotopy(IF GreaterS(DYNX(W_,460),"drive.variableLimiter.u", 
  DYNX(W_,440),"drive.variableLimiter.limit1", 7) THEN DYNX(W_,440) ELSE IF 
  LessS(DYNX(W_,460),"drive.variableLimiter.u", DYNX(W_,441),"drive.variableLimiter.limit2",
   8) THEN DYNX(W_,441) ELSE DYNX(W_,460), DYNX(W_,460));
DYNX(W_,484) = DYNX(X_,8);
DYNX(W_,431) = divGuarded(DYNX(X_,1)-DYNX(W_,43),"battery.EBattery-battery.EBatteryMin",
  DYNX(W_,44)-DYNX(W_,43),"battery.EBatteryMax-battery.EBatteryMin");
AssertModelica(LessEqual(DYNX(W_,431),"battery.SOC", DYNX(DP_,15),
  "battery.SOCMax", 9),"battery.SOC <= battery.SOCMax", StringAdd(StringAdd(
  "State of charge overcomes maximum allowed (max=",Real2String2(DYNX(DP_,15), 
  true, 0)),")"));
AssertModelica(GreaterEqual(DYNX(W_,431),"battery.SOC", DYNX(DP_,14),
  "battery.SOCMin", 10),"battery.SOC >= battery.SOCMin", StringAdd(StringAdd(
  "State of charge is below minimum allowed (min=",Real2String2(DYNX(DP_,14), 
  true, 0)),")"));
DYNX(W_,465) = DYNX(W_,131)-DYNX(W_,431);
DYNX(W_,466) = DYNX(W_,132)*DYNX(W_,465);
DYNX(W_,463) = DYNX(DP_,56)*DYNX(X_,5)+DYNX(DP_,57)*DYNX(W_,466);
DYNX(W_,464) = homotopy(IF GreaterS(DYNX(W_,463),"ems.limiter.u", DYNX(W_,128),
  "ems.limiter.uMax", 11) THEN DYNX(W_,128) ELSE IF LessS(DYNX(W_,463),
  "ems.limiter.u", DYNX(DP_,55),"ems.limiter.uMin", 12) THEN DYNX(DP_,55) ELSE 
  DYNX(W_,463), DYNX(W_,463));
DYNX(W_,401) =  NOT DYNX(Aux_,5) AND Greater(DYNX(W_,464),"ems.powHyst.u", 
  DYNX(W_,134),"ems.powHyst.uHigh", 13) OR DYNX(Aux_,5) AND GreaterEqual(
  DYNX(W_,464),"ems.powHyst.u", DYNX(W_,133),"ems.powHyst.uLow", 14);
DYNX(W_,468) = IF DYNX(W_,401) THEN DYNX(W_,464) ELSE DYNX(DP_,59);
DYNX(W_,473) = homotopy(IF GreaterS(DYNX(W_,468),"genset.limiter.u", 
  DYNX(DP_,67),"genset.limiter.uMax", 15) THEN DYNX(DP_,67) ELSE IF LessS(
  DYNX(W_,468),"genset.limiter.u", DYNX(DP_,68),"genset.limiter.uMin", 16) THEN 
  DYNX(DP_,68) ELSE DYNX(W_,468), DYNX(W_,468));
DYNX(W_,475) = homotopy(IF GreaterS(DYNX(W_,504),"der(genset.speedSensor.flange.phi)",
   DYNX(DP_,92),"genset.gms.limMinW.uMax", 17) THEN DYNX(DP_,92) ELSE IF LessS(
  DYNX(W_,504),"der(genset.speedSensor.flange.phi)", DYNX(DP_,93),
  "genset.gms.limMinW.uMin", 18) THEN DYNX(DP_,93) ELSE DYNX(W_,504), 
  DYNX(W_,504));
DYNX(W_,476) = divGuarded(DYNX(W_,473),"genset.gms.division.u1",DYNX(W_,475),
  "genset.gms.division.u2");
DYNX(W_,482) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DValueNoDer2(\ngenset.gms.maxTau.tableID, \n1, \nder(genset.speedSensor.flange.phi))")
  Modelica_Blocks_Tables_Internal_getTable1DValueNoDer2_M(DymStruc0_construct(
  (Integer)(DYNX(W_,181))), 1, DYNX(W_,504)));
PopModelContext();
DYNX(W_,483) = DYNX(DP_,96)*DYNX(W_,482);
AssertModelica(GreaterEqual(DYNX(W_,482),"genset.gms.tauLimiter.limit1", 
  DYNX(W_,483),"genset.gms.tauLimiter.limit2", 19),"genset.gms.tauLimiter.limit1 >= genset.gms.tauLimiter.limit2",
   "Input signals are not consistent: limit1 < limit2");
DYNX(W_,477) = homotopy(IF GreaterS(DYNX(W_,476),"genset.gms.tauLimiter.u", 
  DYNX(W_,482),"genset.gms.tauLimiter.limit1", 20) THEN DYNX(W_,482) ELSE IF 
  LessS(DYNX(W_,476),"genset.gms.tauLimiter.u", DYNX(W_,483),"genset.gms.tauLimiter.limit2",
   21) THEN DYNX(W_,483) ELSE DYNX(W_,476), DYNX(W_,476));
DYNX(W_,502) = DYNX(W_,357)*DYNX(W_,477);
DYNX(W_,402) = PRE(DYNX(W_,402), 4);
DYNX(W_,485) = 0.0;
  if (Less(DYNX(W_,484),"genset.gen.limTau.w", divGuarded(DYNX(W_,189),
    "genset.gen.limTau.powMax",DYNX(W_,190),"genset.gen.limTau.tauMax"),
    "genset.gen.limTau.powMax/genset.gen.limTau.tauMax", 22)) {
    DYNX(W_,402) = 0;
    DYNX(W_,485) = DYNX(W_,190);
  }
  else{
    DYNX(W_,402) = 1;
    DYNX(W_,485) = divGuarded(DYNX(W_,189),"genset.gen.limTau.powMax",
      DYNX(W_,484),"genset.gen.limTau.w");
  }
  if (Greater(DYNX(W_,484),"genset.gen.limTau.w", DYNX(W_,191),"genset.gen.limTau.wMax",
     23)) {
    if (Less(DYNX(W_,484),"genset.gen.limTau.w", (1+DYNX(DP_,109))*DYNX(W_,191),
      "(1+genset.gen.limTau.alpha)*genset.gen.limTau.wMax", 24)) {
      DYNX(W_,402) = 2;
      DYNX(W_,485) = divGuarded(DYNX(W_,189)*(1-divGuarded(DYNX(W_,484)-
        DYNX(W_,191),"genset.gen.limTau.w-genset.gen.limTau.wMax",DYNX(DP_,109)*
        DYNX(W_,191),"genset.gen.limTau.alpha*genset.gen.limTau.wMax")),
        "genset.gen.limTau.powMax*(1-(genset.gen.limTau.w-genset.gen.limTau.wMax)/(genset.gen.limTau.alpha*genset.gen.limTau.wMax))",
        DYNX(W_,191),"genset.gen.limTau.wMax");
    }
    else{
      DYNX(W_,402) = 3;
      DYNX(W_,485) = 0;
    }
  }
  DYNX(W_,486) =  -DYNX(W_,485);
AssertModelica(GreaterEqual(DYNX(W_,485),"genset.gen.variableLimiter.limit1", 
  DYNX(W_,486),"genset.gen.variableLimiter.limit2", 25),"genset.gen.variableLimiter.limit1 >= genset.gen.variableLimiter.limit2",
   "Input signals are not consistent: limit1 < limit2");
DYNX(W_,489) = homotopy(IF GreaterS(DYNX(W_,502),"genset.gen.variableLimiter.u",
   DYNX(W_,485),"genset.gen.variableLimiter.limit1", 26) THEN DYNX(W_,485) ELSE 
  IF LessS(DYNX(W_,502),"genset.gen.variableLimiter.u", DYNX(W_,486),
  "genset.gen.variableLimiter.limit2", 27) THEN DYNX(W_,486) ELSE DYNX(W_,502), 
  DYNX(W_,502));
DYNX(W_,474) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DValue(\ngenset.gms.optiSpeed.tableID, \n1, \ngenset.gms.optiSpeed.u[1])")
  Modelica_Blocks_Tables_Internal_getTable1DValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,170))), 1, DYNX(W_,473)));
PopModelContext();
DYNX(W_,479) = IF DYNX(W_,401) THEN DYNX(W_,474) ELSE DYNX(DP_,91);
DYNX(W_,480) = 9.549296585513721*DYNX(W_,504);
DYNX(W_,481) = DYNX(W_,479)-DYNX(W_,480);
DYNX(W_,478) = DYNX(W_,171)*DYNX(W_,481);
DYNX(W_,512) = homotopy(IF GreaterS(DYNX(W_,478),"genset.mbIce.limiter.u", 
  DYNX(DP_,195),"genset.mbIce.limiter.uMax", 28) THEN DYNX(DP_,195) ELSE IF 
  LessS(DYNX(W_,478),"genset.mbIce.limiter.u", DYNX(DP_,196),"genset.mbIce.limiter.uMin",
   29) THEN DYNX(DP_,196) ELSE DYNX(W_,478), DYNX(W_,478));
DYNX(W_,519) = homotopy(IF GreaterS(DYNX(W_,518),"driver.limAcc.u", DYNX(W_,379),
  "driver.limAcc.uMax", 30) THEN DYNX(W_,379) ELSE IF LessS(DYNX(W_,518),
  "driver.limAcc.u", DYNX(DP_,207),"driver.limAcc.uMin", 31) THEN DYNX(DP_,207)
   ELSE DYNX(W_,518), DYNX(W_,518));
DYNX(W_,520) = homotopy(IF GreaterS(DYNX(W_,518),"driver.limBrak.u", 
  DYNX(DP_,208),"driver.limBrak.uMax", 32) THEN DYNX(DP_,208) ELSE IF LessS(
  DYNX(W_,518),"driver.limBrak.u", DYNX(W_,382),"driver.limBrak.uMin", 33) THEN 
  DYNX(W_,382) ELSE DYNX(W_,518), DYNX(W_,518));
BreakSectionFunctionEnd()
BreakSectionFunctionStart(3);
InitialSection
InitialSection2
DYNX(W_,398) = DYNX(Aux_,0);
DYNX(W_,396) = DYNX(Aux_,1);
DYNX(W_,395) = DYNX(Aux_,2);
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
 /* Linear dummy derivative system of equations to solve. */
{
  const char*const varnames_[]={"wheel.flangeR.der(phi)", "drive.inertia.w", 
    "mass.v"};
  DidLinearSystemOfEquations(J, b, y, 3, DYNX(DYNhelp,21), 42, DYNX(did_->helpvari_vec,0), 10);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    SetMatrixLeading(J, 1, 1, 3,  -DYNX(DP_,3));
    SetMatrixLeading(J, 1, 2, 3, 1.0);
    SetMatrixLeading(J, 2, 1, 3, DYNX(DP_,2));
    SetMatrixLeading(J, 2, 3, 3, -1.0);
    SetMatrixLeading(J, 3, 1, 3, DYNX(W_,521));
    SetMatrixLeading(J, 3, 2, 3, DYNX(W_,522));
    SetMatrixLeading(J, 3, 3, 3, DYNX(W_,523));
  }
  SetVector(b, 3, DYNX(X_,11));
  SetVector(y, 1, RememberSimple_(DYNX(F_,0), 0));
  SetVector(y, 2, RememberSimple_(DYNX(W_,457), 1));
  SetVector(y, 3, RememberSimple_(DYNX(W_,412), 2));
  #define HaveDummyDerivative_
  DummyLinearDid(J, b, 2, 3, &DYNX(W_,521), RealScalarArray(3, DYNX(F_,0), 
    DYNX(W_,457), DYNX(W_,412)), &DYNX(X_,11), DYNX(DYNhelp,63), 6, 
    DYNX(did_->helpvari_vec,10), 9);
  SolveLinearSystemOfEquations(J, b, y, 1, "simulation.linear[1]");
  DYNX(F_,0) = GetVector(y, 1);
  DYNX(W_,457) = GetVector(y, 2);
  DYNX(W_,412) = GetVector(y, 3);
  EndStaticLinearSystemOfEquations(J);
}
 /* End of Equation Block */ 
DYNX(W_,399) = IF Greater(DYNX(W_,412),"dragForce.v", 0,"0", 34) THEN 1 ELSE -1;
DYNX(W_,516) = DYNTime;
beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,403), 5), 0), 0) 
  DYNX(W_,404) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getNextTimeEvent(\ndriver.driveCyc.tableID, \ndriver.driveCyc.timeScaled)")
    Modelica_Blocks_Tables_Internal_getNextTimeEvent_M(DymStruc0_construct(
    (Integer)(DYNX(W_,377))), DYNX(W_,516)));
  PopModelContext();
endwhenModelica()
endwhenBlock


DYNX(DYNhelp,69) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTimeTableValueNoDer2(\ndriver.driveCyc.tableID, \n1, \ndriver.driveCyc.timeScaled, \ndriver.driveCyc.nextTimeEventScaled, \npre(driver.driveCyc.nextTimeEventScaled))")
  Modelica_Blocks_Tables_Internal_getTimeTableValueNoDer2_M(DymStruc0_construct(
  (Integer)(DYNX(W_,377))), 1, DYNX(W_,516), DYNX(W_,404), PRE(DYNX(W_,404), 1)));
PopModelContext();
DYNX(W_,514) = DYNX(W_,376)+DYNX(DYNhelp,69);
DYNX(W_,515) = 0.2777777777777778*DYNX(W_,514);
DYNX(W_,517) = DYNX(W_,515)-DYNX(W_,412);
DYNX(W_,518) = DYNX(W_,378)*DYNX(W_,517);
DYNX(W_,460) = IF GreaterS(DYNX(W_,518),"driver.limiter1.u", DYNX(W_,385),
  "driver.limiter1.uMax", 1) THEN DYNX(W_,385) ELSE IF LessS(DYNX(W_,518),
  "driver.limiter1.u", DYNX(W_,386),"driver.limiter1.uMin", 2) THEN DYNX(W_,386)
   ELSE DYNX(W_,518);
DYNX(W_,439) = DYNX(W_,457);
DYNX(W_,400) = PRE(DYNX(W_,400), 3);
DYNX(W_,440) = 0.0;
  if (Less(DYNX(W_,439),"drive.limTau.w", divGuarded(DYNX(W_,56),
    "drive.limTau.powMax",DYNX(W_,57),"drive.limTau.tauMax"),"drive.limTau.powMax/drive.limTau.tauMax",
     3)) {
    DYNX(W_,400) = 0;
    DYNX(W_,440) = DYNX(W_,57);
  }
  else{
    DYNX(W_,400) = 1;
    DYNX(W_,440) = divGuarded(DYNX(W_,56),"drive.limTau.powMax",DYNX(W_,439),
      "drive.limTau.w");
  }
  if (Greater(DYNX(W_,439),"drive.limTau.w", DYNX(W_,58),"drive.limTau.wMax", 4))
     {
    if (Less(DYNX(W_,439),"drive.limTau.w", (1+DYNX(DP_,41))*DYNX(W_,58),
      "(1+drive.limTau.alpha)*drive.limTau.wMax", 5)) {
      DYNX(W_,400) = 2;
      DYNX(W_,440) = divGuarded(DYNX(W_,56)*(1-divGuarded(DYNX(W_,439)-
        DYNX(W_,58),"drive.limTau.w-drive.limTau.wMax",DYNX(DP_,41)*DYNX(W_,58),
        "drive.limTau.alpha*drive.limTau.wMax")),"drive.limTau.powMax*(1-(drive.limTau.w-drive.limTau.wMax)/(drive.limTau.alpha*drive.limTau.wMax))",
        DYNX(W_,58),"drive.limTau.wMax");
    }
    else{
      DYNX(W_,400) = 3;
      DYNX(W_,440) = 0;
    }
  }
  DYNX(W_,441) =  -DYNX(W_,440);
AssertModelica(GreaterEqual(DYNX(W_,440),"drive.variableLimiter.limit1", 
  DYNX(W_,441),"drive.variableLimiter.limit2", 6),"drive.variableLimiter.limit1 >= drive.variableLimiter.limit2",
   "Input signals are not consistent: limit1 < limit2");
DYNX(W_,444) = IF GreaterS(DYNX(W_,460),"drive.variableLimiter.u", DYNX(W_,440),
  "drive.variableLimiter.limit1", 7) THEN DYNX(W_,440) ELSE IF LessS(
  DYNX(W_,460),"drive.variableLimiter.u", DYNX(W_,441),"drive.variableLimiter.limit2",
   8) THEN DYNX(W_,441) ELSE DYNX(W_,460);

MixedSystemOfEquations(8, DYNX(DYNhelp,70))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[2] */
  /* Introducing 5 common subexpressions used in 4 expressions */
  /* Of the common subexpressions 5 are reals, 0 are integers, and 0
     are booleans. */
  DYNX(DYNhelp,78) = IF DYNX(W_,397) THEN 0 ELSE IF DYNX(W_,395) THEN  -
    DYNX(W_,17) ELSE IF DYNX(W_,396) THEN DYNX(W_,17) ELSE IF PRE(DYNX(W_,398), 0)
     == 1 THEN  -DYNX(W_,17) ELSE DYNX(W_,17);
  DYNX(DYNhelp,79) = DYNX(W_,18)*sqr(DYNX(W_,412));
  DYNX(DYNhelp,80) = DYNX(DYNhelp,79)*DYNX(W_,399);
  DYNX(DYNhelp,81) = DYNX(DP_,4)*DYNX(DP_,2);
  /* Automatic tearing of linear system of 8 simultaneous equations
  gave a linear system of 2 equations for numerical solution.*/
  DYNX(DYNhelp,82) = IF DYNX(W_,397) THEN 0.0 ELSE 1.0;
  {
  const char*const varnames_[]={"dragForce.sa", "wheel.flangeR.der(phi, 2)"};
  DYNX(W_,418)=RememberSimple_(DYNX(W_,418), 3);
  DYNX(W_,406)=RememberSimple_(DYNX(W_,406), 4);
  SolveLinear2by2((-1.0)*DYNX(DYNhelp,82), DYNX(DP_,2), 
  DYNX(DP_,2)*(IF DYNX(W_,397) THEN 1.0 ELSE 0.0)+DYNX(DYNhelp,81)*
    DYNX(DYNhelp,82), DYNX(W_,116)*DYNX(DP_,3)*DYNX(DP_,3), 
  DYNX(DYNhelp,78), DYNX(DP_,3)*DYNX(W_,444)-(DYNX(DP_,2)*(DYNX(DYNhelp,80)+(IF 
    DYNX(W_,397) THEN 0.0 ELSE DYNX(W_,17)*(IF DYNX(W_,395) THEN 
    (PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.0}, {1.0}, dragForce.v, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays1, 1, 1), 
    RealTemporaryDense( DymArrays2, 1, 1), DYNX(W_,412), 1).yi0_0_0member) ELSE 
    IF DYNX(W_,396) THEN  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.0}, {1.0},  -dragForce.v, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays1, 1, 1), 
    RealTemporaryDense( DymArrays2, 1, 1),  -DYNX(W_,412), 1).yi0_0_0member)
     ELSE IF PRE(DYNX(W_,398), 0) == 1 THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.0}, {1.0}, dragForce.v, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays1, 1, 1), 
    RealTemporaryDense( DymArrays2, 1, 1), DYNX(W_,412), 1).yi0_0_0member) ELSE 
     -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.0}, {1.0},  -dragForce.v, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays1, 1, 1), 
    RealTemporaryDense( DymArrays2, 1, 1),  -DYNX(W_,412), 1).yi0_0_0member))))+
    DYNX(DYNhelp,81)*DYNX(DYNhelp,78)), &DYNX(W_,418), &DYNX(W_,406), 
  varnames_, &MixedFailFlag_, "simulation.linear[2]");
  }
  DYNX(W_,411) =  -(DYNX(DYNhelp,80)+(IF DYNX(W_,397) THEN DYNX(W_,418) ELSE 
    DYNX(W_,17)*(IF DYNX(W_,395) THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.0}, {1.0}, dragForce.v, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays1, 1, 1), 
    RealTemporaryDense( DymArrays2, 1, 1), DYNX(W_,412), 1).yi0_0_0member) ELSE 
    IF DYNX(W_,396) THEN  -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.0}, {1.0},  -dragForce.v, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays1, 1, 1), 
    RealTemporaryDense( DymArrays2, 1, 1),  -DYNX(W_,412), 1).yi0_0_0member)
     ELSE IF PRE(DYNX(W_,398), 0) == 1 THEN (PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.0}, {1.0}, dragForce.v, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays1, 1, 1), 
    RealTemporaryDense( DymArrays2, 1, 1), DYNX(W_,412), 1).yi0_0_0member) ELSE 
     -(PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.0}, {1.0},  -dragForce.v, 1)")
    Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays1, 1, 1), 
    RealTemporaryDense( DymArrays2, 1, 1),  -DYNX(W_,412), 1).yi0_0_0member))));
  PopAllMarks();
  DYNX(W_,413) = IF DYNX(W_,397) THEN 0 ELSE IF DYNX(W_,395) THEN DYNX(W_,418)-
    DYNX(W_,17) ELSE IF DYNX(W_,396) THEN DYNX(W_,418)+DYNX(W_,17) ELSE IF PRE(
    DYNX(W_,398), 0) == 1 THEN DYNX(W_,418)-DYNX(W_,17) ELSE DYNX(W_,418)+
    DYNX(W_,17);
  DYNX(W_,408) = DYNX(W_,411)-DYNX(DP_,4)*DYNX(W_,413);
  DYNX(W_,407) =  -DYNX(DP_,2)*DYNX(W_,408);
  DYNX(W_,458) = DYNX(DP_,3)*DYNX(W_,406);
  DYNX(W_,409) = DYNX(W_,444)-DYNX(W_,116)*DYNX(W_,458);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,395),"dragForce.startForward", PRE(DYNX(W_,398), 0)
     == 0 AND Greater(DYNX(W_,418),"dragForce.sa", DYNX(W_,17),"dragForce.f0_max",
     35) OR PRE(DYNX(W_,398), 0) == -1 AND Greater(DYNX(W_,412),"dragForce.v", 
    DYNX(DP_,6),"dragForce.v_small", 36) OR initial() AND Greater(DYNX(W_,412),
    "dragForce.v", 0,"0", 34));
  UpdateVariableNamed(DYNX(W_,396),"dragForce.startBackward", PRE(DYNX(W_,398), 0)
     == 0 AND Less(DYNX(W_,418),"dragForce.sa",  -DYNX(W_,17)," -dragForce.f0_max",
     37) OR PRE(DYNX(W_,398), 0) == 1 AND Less(DYNX(W_,412),"dragForce.v",  -
    DYNX(DP_,6)," -dragForce.v_small", 38) OR initial() AND Less(DYNX(W_,412),
    "dragForce.v", 0,"0", 39));
  UpdateVariableNamed(DYNX(W_,397),"dragForce.locked",  NOT (PRE(DYNX(W_,398), 0)
     == 1 OR DYNX(W_,395) OR PRE(DYNX(W_,398), 0) == -1 OR DYNX(W_,396)));
  MixedModeInit(6, DYNX(DYNhelp,83))
  ThetaMixedCross(0,34)
  ThetaMixedCross(1,35)
  ThetaMixedCross(2,36)
  ThetaMixedCross(3,37)
  ThetaMixedCross(4,38)
  ThetaMixedCross(5,39)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,458), 1)
  UpdateReal(DYNX(W_,409), 2)
  UpdateReal(DYNX(W_,407), 3)
  UpdateReal(DYNX(W_,408), 4)
  UpdateReal(DYNX(W_,418), 5)
  UpdateReal(DYNX(W_,411), 6)
  UpdateReal(DYNX(W_,413), 7)
  UpdateReal(DYNX(W_,406), 8)
EndMixedSystemOfEquations

DYNX(F_,11) = DYNX(W_,521)*DYNX(W_,406)+DYNX(W_,522)*DYNX(W_,458)+DYNX(W_,523)*
  DYNX(W_,413);
DYNX(W_,484) = DYNX(X_,8);
DYNX(F_,6) = DYNX(W_,484);
DYNX(W_,423) = DYNX(X_,2)+DYNX(X_,1);
DYNX(W_,421) = DYNX(X_,3)-DYNX(W_,423);
 /* Linear system of equations to solve. */
DYNX(W_,422) = RememberSimple_(DYNX(W_,422), 5);
SolveScalarLinearParametric( -DYNX(W_,29)," -battery.R0.R_actual",  -
  DYNX(W_,421)," -battery.R0.v", DYNX(W_,422),"battery.R0.p.i");
 /* End of Equation Block */ 

DYNX(W_,437) =  -DYNX(W_,52)*DYNX(W_,422);
DYNX(W_,436) = IF DYNX(W_,437) >= 0 THEN DYNX(W_,437) ELSE  -DYNX(W_,437);
DYNX(W_,427) = DYNX(W_,423)-DYNX(X_,1);
 /* Linear system of equations to solve. */
DYNX(W_,428) = RememberSimple_(DYNX(W_,428), 6);
SolveScalarLinearParametric( -DYNX(W_,35)," -battery.R1.R_actual",  -
  DYNX(W_,427)," -battery.R1.v", DYNX(W_,428),"battery.R1.p.i");
 /* End of Equation Block */ 

DYNX(W_,430) =  -(DYNX(W_,436)-DYNX(W_,422)+DYNX(W_,428));
DYNX(W_,420) = DYNX(W_,430)+DYNX(W_,428);
 /* Linear system of equations to solve. */
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 7);
SolveScalarLinearParametric( -DYNX(W_,25)," -battery.cBattery.C",  -DYNX(W_,420),
  " -battery.cBattery.i", DYNX(F_,1),"der(battery.cBattery.v)");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(F_,2) = RememberSimple_(DYNX(F_,2), 8);
SolveScalarLinearParametric( -DYNX(W_,36)," -battery.C1.C",  -DYNX(W_,430),
  " -battery.C1.i", DYNX(F_,2),"der(battery.C1.v)");
 /* End of Equation Block */ 

DYNX(W_,431) = divGuarded(DYNX(X_,1)-DYNX(W_,43),"battery.EBattery-battery.EBatteryMin",
  DYNX(W_,44)-DYNX(W_,43),"battery.EBatteryMax-battery.EBatteryMin");
DYNX(W_,465) = DYNX(W_,131)-DYNX(W_,431);
DYNX(W_,466) = DYNX(W_,132)*DYNX(W_,465);
DYNX(W_,463) = DYNX(DP_,56)*DYNX(X_,5)+DYNX(DP_,57)*DYNX(W_,466);
DYNX(W_,464) = IF GreaterS(DYNX(W_,463),"ems.limiter.u", DYNX(W_,128),
  "ems.limiter.uMax", 11) THEN DYNX(W_,128) ELSE IF LessS(DYNX(W_,463),
  "ems.limiter.u", DYNX(DP_,55),"ems.limiter.uMin", 12) THEN DYNX(DP_,55) ELSE 
  DYNX(W_,463);
DYNX(W_,401) =  NOT PRE(DYNX(W_,401), 2) AND Greater(DYNX(W_,464),
  "ems.powHyst.u", DYNX(W_,134),"ems.powHyst.uHigh", 13) OR PRE(DYNX(W_,401), 2)
   AND GreaterEqual(DYNX(W_,464),"ems.powHyst.u", DYNX(W_,133),"ems.powHyst.uLow",
   14);
DYNX(W_,468) = IF DYNX(W_,401) THEN DYNX(W_,464) ELSE DYNX(DP_,59);
DYNX(W_,473) = IF GreaterS(DYNX(W_,468),"genset.limiter.u", DYNX(DP_,67),
  "genset.limiter.uMax", 15) THEN DYNX(DP_,67) ELSE IF LessS(DYNX(W_,468),
  "genset.limiter.u", DYNX(DP_,68),"genset.limiter.uMin", 16) THEN DYNX(DP_,68)
   ELSE DYNX(W_,468);
DYNX(W_,504) = DYNX(W_,140)*DYNX(X_,8);
DYNX(W_,475) = IF GreaterS(DYNX(W_,504),"der(genset.speedSensor.flange.phi)", 
  DYNX(DP_,92),"genset.gms.limMinW.uMax", 17) THEN DYNX(DP_,92) ELSE IF LessS(
  DYNX(W_,504),"der(genset.speedSensor.flange.phi)", DYNX(DP_,93),
  "genset.gms.limMinW.uMin", 18) THEN DYNX(DP_,93) ELSE DYNX(W_,504);
DYNX(W_,476) = divGuarded(DYNX(W_,473),"genset.gms.division.u1",DYNX(W_,475),
  "genset.gms.division.u2");
DYNX(W_,482) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DValueNoDer2(\ngenset.gms.maxTau.tableID, \n1, \nder(genset.speedSensor.flange.phi))")
  Modelica_Blocks_Tables_Internal_getTable1DValueNoDer2_M(DymStruc0_construct(
  (Integer)(DYNX(W_,181))), 1, DYNX(W_,504)));
PopModelContext();
DYNX(W_,483) = DYNX(DP_,96)*DYNX(W_,482);
AssertModelica(GreaterEqual(DYNX(W_,482),"genset.gms.tauLimiter.limit1", 
  DYNX(W_,483),"genset.gms.tauLimiter.limit2", 19),"genset.gms.tauLimiter.limit1 >= genset.gms.tauLimiter.limit2",
   "Input signals are not consistent: limit1 < limit2");
DYNX(W_,477) = IF GreaterS(DYNX(W_,476),"genset.gms.tauLimiter.u", DYNX(W_,482),
  "genset.gms.tauLimiter.limit1", 20) THEN DYNX(W_,482) ELSE IF LessS(
  DYNX(W_,476),"genset.gms.tauLimiter.u", DYNX(W_,483),"genset.gms.tauLimiter.limit2",
   21) THEN DYNX(W_,483) ELSE DYNX(W_,476);
DYNX(W_,502) = DYNX(W_,357)*DYNX(W_,477);
DYNX(W_,402) = PRE(DYNX(W_,402), 4);
DYNX(W_,485) = 0.0;
  if (Less(DYNX(W_,484),"genset.gen.limTau.w", divGuarded(DYNX(W_,189),
    "genset.gen.limTau.powMax",DYNX(W_,190),"genset.gen.limTau.tauMax"),
    "genset.gen.limTau.powMax/genset.gen.limTau.tauMax", 22)) {
    DYNX(W_,402) = 0;
    DYNX(W_,485) = DYNX(W_,190);
  }
  else{
    DYNX(W_,402) = 1;
    DYNX(W_,485) = divGuarded(DYNX(W_,189),"genset.gen.limTau.powMax",
      DYNX(W_,484),"genset.gen.limTau.w");
  }
  if (Greater(DYNX(W_,484),"genset.gen.limTau.w", DYNX(W_,191),"genset.gen.limTau.wMax",
     23)) {
    if (Less(DYNX(W_,484),"genset.gen.limTau.w", (1+DYNX(DP_,109))*DYNX(W_,191),
      "(1+genset.gen.limTau.alpha)*genset.gen.limTau.wMax", 24)) {
      DYNX(W_,402) = 2;
      DYNX(W_,485) = divGuarded(DYNX(W_,189)*(1-divGuarded(DYNX(W_,484)-
        DYNX(W_,191),"genset.gen.limTau.w-genset.gen.limTau.wMax",DYNX(DP_,109)*
        DYNX(W_,191),"genset.gen.limTau.alpha*genset.gen.limTau.wMax")),
        "genset.gen.limTau.powMax*(1-(genset.gen.limTau.w-genset.gen.limTau.wMax)/(genset.gen.limTau.alpha*genset.gen.limTau.wMax))",
        DYNX(W_,191),"genset.gen.limTau.wMax");
    }
    else{
      DYNX(W_,402) = 3;
      DYNX(W_,485) = 0;
    }
  }
  DYNX(W_,486) =  -DYNX(W_,485);
AssertModelica(GreaterEqual(DYNX(W_,485),"genset.gen.variableLimiter.limit1", 
  DYNX(W_,486),"genset.gen.variableLimiter.limit2", 25),"genset.gen.variableLimiter.limit1 >= genset.gen.variableLimiter.limit2",
   "Input signals are not consistent: limit1 < limit2");
DYNX(W_,489) = IF GreaterS(DYNX(W_,502),"genset.gen.variableLimiter.u", 
  DYNX(W_,485),"genset.gen.variableLimiter.limit1", 26) THEN DYNX(W_,485) ELSE 
  IF LessS(DYNX(W_,502),"genset.gen.variableLimiter.u", DYNX(W_,486),
  "genset.gen.variableLimiter.limit2", 27) THEN DYNX(W_,486) ELSE DYNX(W_,502);
DYNX(W_,511) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DValueNoDer2(\ngenset.mbIce.toLimTau.tableID, \n1, \nder(genset.mbIce.w.flange.phi))")
  Modelica_Blocks_Tables_Internal_getTable1DValueNoDer2_M(DymStruc0_construct(
  (Integer)(DYNX(W_,354))), 1, DYNX(W_,504)));
PopModelContext();
DYNX(W_,474) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DValue(\ngenset.gms.optiSpeed.tableID, \n1, \ngenset.gms.optiSpeed.u[1])")
  Modelica_Blocks_Tables_Internal_getTable1DValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,170))), 1, DYNX(W_,473)));
PopModelContext();
DYNX(W_,479) = IF DYNX(W_,401) THEN DYNX(W_,474) ELSE DYNX(DP_,91);
DYNX(W_,480) = 9.549296585513721*DYNX(W_,504);
DYNX(W_,481) = DYNX(W_,479)-DYNX(W_,480);
DYNX(W_,478) = DYNX(W_,171)*DYNX(W_,481);
DYNX(W_,512) = IF GreaterS(DYNX(W_,478),"genset.mbIce.limiter.u", DYNX(DP_,195),
  "genset.mbIce.limiter.uMax", 28) THEN DYNX(DP_,195) ELSE IF LessS(DYNX(W_,478),
  "genset.mbIce.limiter.u", DYNX(DP_,196),"genset.mbIce.limiter.uMin", 29) THEN 
  DYNX(DP_,196) ELSE DYNX(W_,478);
DYNX(W_,503) = DYNX(W_,511)*DYNX(W_,512);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[3] */
DYNX(F_,8) = RememberSimple_(DYNX(F_,8), 9);
SolveScalarLinearParametric(DYNX(W_,249)+DYNX(W_,257)*DYNX(W_,140)*DYNX(W_,140),
  "genset.gen.inertia.J+genset.mbIce.inertia.J*genset.idealGear.ratio*genset.idealGear.ratio",
   DYNX(W_,489)+DYNX(W_,140)*DYNX(W_,503),"genset.gen.inertia.flange_a.tau+genset.idealGear.ratio*genset.mbIce.inertia.flange_a.tau",
   DYNX(F_,8),"der(genset.gen.inertia.w)");
DYNX(W_,505) = DYNX(W_,140)*DYNX(F_,8);
DYNX(W_,470) = DYNX(W_,503)-DYNX(W_,257)*DYNX(W_,505);
DYNX(W_,471) =  -DYNX(W_,140)*DYNX(W_,470);
 /* End of Equation Block */ 

DYNX(W_,493) = DYNX(W_,489)*DYNX(W_,484);
DYNX(W_,491) = IF DYNX(W_,489) >= 0 THEN DYNX(W_,489) ELSE  -DYNX(W_,489);
DYNX(W_,487) = DYNX(W_,225)*DYNX(W_,491);
DYNX(W_,490) = IF DYNX(W_,484) >= 0 THEN DYNX(W_,484) ELSE  -DYNX(W_,484);
DYNX(W_,488) = DYNX(W_,226)*DYNX(W_,490);
DYNX(W_,492) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable2DValueNoDer2(\ngenset.gen.toElePow.toEff.tableID, \ngenset.gen.toElePow.toEff.u1, \ngenset.gen.toElePow.toEff.u2)")
  Modelica_Blocks_Tables_Internal_getTable2DValueNoDer2_M(DymStruc0_construct(
  (Integer)(DYNX(W_,222))), DYNX(W_,487), DYNX(W_,488)));
PopModelContext();
DYNX(W_,494) = 0.0;
  if (DYNX(W_,493) <= 0) {
    DYNX(W_,494) = DYNX(W_,493)*DYNX(W_,492);
  }
  else{
    DYNX(W_,494) = divGuarded(DYNX(W_,493),"genset.gen.toElePow.applyEta.P",
      DYNX(W_,492),"genset.gen.toElePow.applyEta.eta");
  }
DYNX(W_,498) = DYNX(DP_,115)*DYNX(W_,494);
DYNX(W_,500) = divGuarded(DYNX(X_,7),"genset.gen.constPDC.varCond.G",1+
  DYNX(DP_,113)*(DYNX(W_,242)-DYNX(DP_,112)),"1+genset.gen.constPDC.varCond.alpha*(genset.gen.constPDC.varCond.T_heatPort-genset.gen.constPDC.varCond.T_ref)");
DYNX(W_,461) =  -DYNX(W_,500)*DYNX(X_,3);
DYNX(W_,496) =  -DYNX(X_,3)*DYNX(W_,461);
DYNX(W_,497) = DYNX(W_,498)-DYNX(W_,496);
DYNX(F_,7) = DYNX(W_,243)*DYNX(W_,497);
DYNX(W_,448) = DYNX(W_,444)*DYNX(W_,439);
DYNX(W_,446) = IF DYNX(W_,444) >= 0 THEN DYNX(W_,444) ELSE  -DYNX(W_,444);
DYNX(W_,442) = DYNX(W_,92)*DYNX(W_,446);
DYNX(W_,445) = IF DYNX(W_,439) >= 0 THEN DYNX(W_,439) ELSE  -DYNX(W_,439);
DYNX(W_,443) = DYNX(W_,93)*DYNX(W_,445);
DYNX(W_,447) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable2DValueNoDer2(\ndrive.toElePow.toEff.tableID, \ndrive.toElePow.toEff.u1, \ndrive.toElePow.toEff.u2)")
  Modelica_Blocks_Tables_Internal_getTable2DValueNoDer2_M(DymStruc0_construct(
  (Integer)(DYNX(W_,89))), DYNX(W_,442), DYNX(W_,443)));
PopModelContext();
DYNX(W_,449) = 0.0;
  if (DYNX(W_,448) <= 0) {
    DYNX(W_,449) = DYNX(W_,448)*DYNX(W_,447);
  }
  else{
    DYNX(W_,449) = divGuarded(DYNX(W_,448),"drive.toElePow.applyEta.P",
      DYNX(W_,447),"drive.toElePow.applyEta.eta");
  }
DYNX(W_,454) = DYNX(DP_,47)*DYNX(W_,449);
DYNX(W_,456) = divGuarded(DYNX(X_,4),"drive.constPDC.varCond.G",1+DYNX(DP_,45)*(
  DYNX(W_,109)-DYNX(DP_,44)),"1+drive.constPDC.varCond.alpha*(drive.constPDC.varCond.T_heatPort-drive.constPDC.varCond.T_ref)");
DYNX(W_,451) =  -DYNX(W_,456)*DYNX(X_,3);
DYNX(W_,452) =  -DYNX(X_,3)*DYNX(W_,451);
DYNX(W_,453) = DYNX(W_,454)-DYNX(W_,452);
DYNX(F_,4) = DYNX(W_,110)*DYNX(W_,453);
DYNX(W_,425) = DYNX(W_,451)+DYNX(W_,461);
DYNX(W_,432) = DYNX(W_,425)-DYNX(W_,422);
 /* Linear system of equations to solve. */
DYNX(F_,3) = RememberSimple_(DYNX(F_,3), 10);
SolveScalarLinearParametric( -DYNX(W_,38)," -battery.cDummy.C",  -DYNX(W_,432),
  " -battery.cDummy.i", DYNX(F_,3),"der(battery.cDummy.v)");
 /* End of Equation Block */ 

DYNX(W_,467) =  -DYNX(X_,3)*DYNX(W_,451);
if (NewParameters_) {
DYNX(DYNhelp,89) = divinvGuarded(DYNX(W_,135),"ems.powFilt.T");
}
DYNX(F_,5) = DYNX(DYNhelp,89)*(DYNX(DP_,60)*DYNX(W_,467)-DYNX(X_,5));
DYNX(W_,508) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable2DValueNoDer2(\ngenset.mbIce.toGramsPerkWh.tableID, \ngenset.mbIce.toGramsPerkWh.u1, \nder(genset.mbIce.w.flange.phi))")
  Modelica_Blocks_Tables_Internal_getTable2DValueNoDer2_M(DymStruc0_construct(
  (Integer)(DYNX(W_,330))), DYNX(W_,503), DYNX(W_,504)));
PopModelContext();
DYNX(W_,507) = DYNX(W_,504)*DYNX(W_,503);
DYNX(W_,509) = DYNX(DP_,190)*DYNX(W_,507);
DYNX(W_,510) = IF DYNX(DP_,197) THEN DYNX(W_,509) ELSE DYNX(DP_,193);
DYNX(W_,513) = DYNX(W_,508)*DYNX(W_,510);
DYNX(F_,9) = DYNX(DP_,191)*DYNX(W_,513);
DYNX(F_,10) = DYNX(DP_,198)*DYNX(W_,513);
AssertModelica(Less(fabs(divGuarded(DYNX(W_,425),"battery.p.i",DYNX(DP_,22),
  "battery.np")),"abs(battery.p.i/battery.np)", DYNX(DP_,17),"battery.ICellMax",
   40),"abs(battery.p.i/battery.np) < battery.ICellMax", StringAdd(StringAdd(
  StringAdd(StringAdd("Battery cell current i=",Real2String2(fabs(divGuarded(
  DYNX(W_,425),"battery.p.i",DYNX(DP_,22),"battery.np")), true, 0)),
  "\n exceeds max admissable ICellMax (="),Real2String2(DYNX(DP_,17), true, 0)),
  "A)"));
AssertModelica(LessEqual(DYNX(W_,431),"battery.SOC", DYNX(DP_,15),
  "battery.SOCMax", 9),"battery.SOC <= battery.SOCMax", StringAdd(StringAdd(
  "State of charge overcomes maximum allowed (max=",Real2String2(DYNX(DP_,15), 
  true, 0)),")"));
AssertModelica(GreaterEqual(DYNX(W_,431),"battery.SOC", DYNX(DP_,14),
  "battery.SOCMin", 10),"battery.SOC >= battery.SOCMin", StringAdd(StringAdd(
  "State of charge is below minimum allowed (min=",Real2String2(DYNX(DP_,14), 
  true, 0)),")"));

AcceptedSection1
DYNX(W_,398) = IF (PRE(DYNX(W_,398), 0) == 1 OR PRE(DYNX(W_,398), 0) == 2 OR 
  DYNX(W_,395)) AND Greater(DYNX(W_,412),"dragForce.v", 0,"0", 34) THEN 1 ELSE 
  IF (PRE(DYNX(W_,398), 0) == -1 OR PRE(DYNX(W_,398), 0) == 2 OR DYNX(W_,396))
   AND Less(DYNX(W_,412),"dragForce.v", 0,"0", 39) THEN -1 ELSE 0;
beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,403), 5), 0), 1) 
  DYNX(W_,403) = IF Less(DYNX(W_,404),"driver.driveCyc.nextTimeEventScaled", 
    1E+60,"1E+60", 0) THEN DYNX(W_,404) ELSE 1E+60;
endwhenModelica()
endwhenBlock



AcceptedSection2
DYNX(W_,435) = DYNX(X_,1);
DYNX(W_,414) = (DYNX(X_,0)-DYNX(DP_,0))*DYNX(DP_,2)+DYNX(DP_,1);
DYNX(W_,410) = DYNX(W_,414)+DYNX(DP_,5)/(double)(2);
DYNX(W_,416) = DYNX(W_,410)+DYNX(DP_,5)/(double)(2);
DYNX(W_,438) = DYNX(DP_,3)*DYNX(X_,0);
DYNX(W_,469) = DYNX(W_,140)*DYNX(X_,6);
DYNX(W_,426) =  -(DYNX(W_,436)+DYNX(W_,420)+DYNX(W_,432));
DYNX(W_,405) =  -(DYNX(W_,426)+DYNX(W_,451)+DYNX(W_,461));
DYNX(W_,415) =  -DYNX(W_,408)*DYNX(W_,412);
DYNX(W_,417) =  -DYNX(W_,411)*DYNX(W_,412);
DYNX(W_,424) = DYNX(W_,421)*DYNX(W_,422);
DYNX(W_,429) = DYNX(W_,427)*DYNX(W_,428);
DYNX(W_,419) = DYNX(W_,424)+DYNX(W_,429)+DYNX(W_,423)*DYNX(W_,436);
DYNX(W_,433) = DYNX(DYNhelp,1)*DYNX(X_,1);
DYNX(W_,434) = DYNX(DYNhelp,2)*DYNX(W_,436);
DYNX(W_,450) = fabs(DYNX(W_,449)-DYNX(W_,448));
DYNX(W_,455) =  -DYNX(X_,3)*DYNX(W_,451);
DYNX(W_,459) = DYNX(W_,409)*DYNX(W_,439);
DYNX(W_,462) = DYNX(X_,3)*DYNX(W_,461);
DYNX(W_,472) =  -DYNX(W_,471)*DYNX(W_,484);
DYNX(W_,495) = fabs(DYNX(W_,494)-DYNX(W_,493));
DYNX(W_,499) =  -DYNX(X_,3)*DYNX(W_,461);
DYNX(W_,501) = DYNX(W_,471)*DYNX(W_,484);
DYNX(W_,506) = DYNX(W_,470)*DYNX(W_,504);
DYNX(W_,519) = IF GreaterS(DYNX(W_,518),"driver.limAcc.u", DYNX(W_,379),
  "driver.limAcc.uMax", 30) THEN DYNX(W_,379) ELSE IF LessS(DYNX(W_,518),
  "driver.limAcc.u", DYNX(DP_,207),"driver.limAcc.uMin", 31) THEN DYNX(DP_,207)
   ELSE DYNX(W_,518);
DYNX(W_,520) = IF GreaterS(DYNX(W_,518),"driver.limBrak.u", DYNX(DP_,208),
  "driver.limBrak.uMax", 32) THEN DYNX(DP_,208) ELSE IF LessS(DYNX(W_,518),
  "driver.limBrak.u", DYNX(W_,382),"driver.limBrak.uMin", 33) THEN DYNX(W_,382)
   ELSE DYNX(W_,518);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("ground1.p.v", "Potential at the pin [V]", 0, 0, 0.0,0.0,0.0,0,521)
DeclareVariable("ground1.p.i", "Current flowing into the pin [A]", 405, 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("wheel.useSupportR", "= true, if rotational support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 1, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("wheel.useSupportT", "= true, if translational support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 2, false, 0.0,0.0,0.0,0,1539)
DeclareState("wheel.flangeR.phi", "Absolute rotation angle of flange [rad|deg]",\
 0, 0.0, 0.0,0.0,0.0,0,568)
DeclareDerivative("wheel.flangeR.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 0, 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("wheel.flangeR.der(phi, 2)", "der(Absolute rotation angle of flange2) [rad/s2]",\
 406, 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("wheel.flangeR.tau", "Cut torque in the flange [N.m]", 407, 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("wheel.flangeT.s", "Absolute position of flange [m]", \
"powProp.flange_a.s", 1, 5, 414, 4)
DeclareVariable("wheel.flangeT.f", "Cut force directed into flange [N]", 408, \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("wheel.internalSupportR.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "wheel.flangeR.tau", -1, 5, 407, 1024)
DeclareAlias2("wheel.internalSupportR.phi", "External support angle (= flange.phi) [rad|deg]",\
 "wheel.fixedR.phi0", 1, 7, 0, 1024)
DeclareAlias2("wheel.internalSupportR.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "wheel.fixedR.phi0", 1, 7, 0, 1028)
DeclareAlias2("wheel.internalSupportR.flange.tau", "Cut torque in the flange [N.m]",\
 "wheel.flangeR.tau", -1, 5, 407, 1156)
DeclareAlias2("wheel.internalSupportT.f", "External support force (must be computed via force balance in model where InternalSupport is used; = flange.f) [N]",\
 "wheel.flangeT.f", -1, 5, 408, 1024)
DeclareAlias2("wheel.internalSupportT.s", "External support position (= flange.s) [m]",\
 "wheel.fixedT.s0", 1, 7, 1, 1024)
DeclareAlias2("wheel.internalSupportT.flange.s", "Absolute position of flange [m]",\
 "wheel.fixedT.s0", 1, 7, 1, 1028)
DeclareAlias2("wheel.internalSupportT.flange.f", "Cut force directed into flange [N]",\
 "wheel.flangeT.f", -1, 5, 408, 1156)
DeclareParameter("wheel.fixedR.phi0", "Fixed offset angle of housing [rad|deg]",\
 0, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("wheel.fixedR.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "wheel.fixedR.phi0", 1, 7, 0, 1028)
DeclareAlias2("wheel.fixedR.flange.tau", "Cut torque in the flange [N.m]", \
"wheel.flangeR.tau", 1, 5, 407, 1156)
DeclareParameter("wheel.fixedT.s0", "Fixed offset position of housing [m]", 1, 0,\
 0.0,0.0,0.0,0,2608)
DeclareAlias2("wheel.fixedT.flange.s", "Absolute position of flange [m]", \
"wheel.fixedT.s0", 1, 7, 1, 1028)
DeclareAlias2("wheel.fixedT.flange.f", "Cut force directed into flange [N]", \
"wheel.flangeT.f", 1, 5, 408, 1156)
DeclareParameter("wheel.radius", "Wheel radius [m]", 2, 0.473, 0.0,1E+100,0.0,0,560)
DeclareVariable("gear.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 3, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("gear.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.wSensor.flange.phi", 1, 5, 438, 4)
DeclareVariable("gear.flange_a.tau", "Cut torque in the flange [N.m]", 409, 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("gear.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "wheel.flangeR.phi", 1, 1, 0, 4)
DeclareAlias2("gear.flange_b.tau", "Cut torque in the flange [N.m]", \
"wheel.flangeR.tau", -1, 5, 407, 132)
DeclareVariable("gear.phi_support", "Absolute angle of support flange [rad|deg]",\
 4, 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("gear.ratio", "Transmission ratio (flange_a.phi/flange_b.phi)",\
 3, 10, 0.0,0.0,0.0,0,560)
DeclareAlias2("gear.phi_a", "Angle between left shaft flange and support [rad|deg]",\
 "drive.wSensor.flange.phi", 1, 5, 438, 0)
DeclareAlias2("gear.phi_b", "Angle between right shaft flange and support [rad|deg]",\
 "wheel.flangeR.phi", 1, 1, 0, 0)
DeclareParameter("mass.m", "Mass of the sliding mass [kg]", 4, 14000, 0.0,1E+100,\
0.0,0,560)
DeclareVariable("mass.stateSelect", "Priority to use s and v as states [:#(type=StateSelect)]",\
 5, 3, 1.0,5.0,0.0,0,517)
DeclareVariable("mass.s", "Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2) [m]",\
 410, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("mass.der(s)", "der(Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)) [m/s]",\
 "mass.v", 1, 5, 412, 0)
DeclareParameter("mass.L", "Length of component, from left flange to right flange (= flange_b.s - flange_a.s) [m]",\
 5, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("mass.flange_a.s", "Absolute position of flange [m]", \
"powProp.flange_a.s", 1, 5, 414, 4)
DeclareAlias2("mass.flange_a.f", "Cut force directed into flange [N]", \
"wheel.flangeT.f", -1, 5, 408, 132)
DeclareAlias2("mass.flange_b.s", "Absolute position of flange [m]", \
"powDrag.flange_a.s", 1, 5, 416, 4)
DeclareVariable("mass.flange_b.f", "Cut force directed into flange [N]", 411, \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("mass.v", "Absolute velocity of component [m/s]", 412, 0, \
0.0,0.0,0.0,0,528)
DeclareVariable("mass.der(v)", "der(Absolute velocity of component) [m/s2]", 413,\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("mass.a", "Absolute acceleration of component [m/s2]", \
"mass.der(v)", 1, 5, 413, 0)
DeclareVariable("powProp.flange_a.s", "Absolute position of flange [m]", 414, \
0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("powProp.flange_a.der(s)", "der(Absolute position of flange) [m/s]",\
 "mass.v", 1, 5, 412, 4)
DeclareAlias2("powProp.flange_a.f", "Cut force directed into flange [N]", \
"wheel.flangeT.f", -1, 5, 408, 132)
DeclareAlias2("powProp.flange_b.s", "Absolute position of flange [m]", \
"powProp.flange_a.s", 1, 5, 414, 4)
DeclareAlias2("powProp.flange_b.f", "Cut force directed into flange [N]", \
"wheel.flangeT.f", 1, 5, 408, 132)
DeclareVariable("powProp.power", "Power in flange flange_a as output signal [W]",\
 415, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("powDrag.flange_a.s", "Absolute position of flange [m]", 416, \
0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("powDrag.flange_a.der(s)", "der(Absolute position of flange) [m/s]",\
 "mass.v", 1, 5, 412, 4)
DeclareAlias2("powDrag.flange_a.f", "Cut force directed into flange [N]", \
"mass.flange_b.f", -1, 5, 411, 132)
DeclareAlias2("powDrag.flange_b.s", "Absolute position of flange [m]", \
"powDrag.flange_a.s", 1, 5, 416, 4)
DeclareAlias2("powDrag.flange_b.f", "Cut force directed into flange [N]", \
"mass.flange_b.f", 1, 5, 411, 132)
DeclareVariable("powDrag.power", "Power in flange flange_a as output signal [W]",\
 417, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dragForce.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 6, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("dragForce.s", "Distance between flange and support (= flange.s - support.s) [m]",\
 "powDrag.flange_a.s", 1, 5, 416, 0)
DeclareAlias2("dragForce.der(s)", "der(Distance between flange and support (= flange.s - support.s)) [m/s]",\
 "mass.v", 1, 5, 412, 0)
DeclareAlias2("dragForce.flange.s", "Absolute position of flange [m]", \
"powDrag.flange_a.s", 1, 5, 416, 4)
DeclareAlias2("dragForce.flange.f", "Cut force directed into flange [N]", \
"mass.flange_b.f", -1, 5, 411, 132)
DeclareVariable("dragForce.s_support", "Absolute position of support flange [m]",\
 7, 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("dragForce.v_small", "Relative velocity near to zero (see model info text) [m/s]",\
 6, 0.001, 0.0,0.0,0.0,0,560)
DeclareAlias2("dragForce.v_relfric", "Relative velocity between frictional surfaces [m/s]",\
 "mass.v", 1, 5, 412, 0)
DeclareAlias2("dragForce.a_relfric", "Relative acceleration between frictional surfaces [m/s2]",\
 "mass.der(v)", 1, 5, 413, 0)
DeclareAlias2("dragForce.f0", "Friction force for v_relfric=0 and forward sliding [N]",\
 "dragForce.A", 1, 5, 17, 0)
DeclareAlias2("dragForce.f0_max", "Maximum friction force for v_relfric=0 and locked [N]",\
 "dragForce.A", 1, 5, 17, 0)
DeclareVariable("dragForce.free", "= true, if frictional element is not active [:#(type=Boolean)]",\
 8, false, 0.0,0.0,0.0,0,515)
DeclareVariable("dragForce.sa", "Path parameter of friction characteristic f = f(a_relfric) [1]",\
 418, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dragForce.startForward", "= true, if v_relfric=0 and start of forward sliding [:#(type=Boolean)]",\
 395, false, 0.0,0.0,0.0,0,722)
DeclareVariable("dragForce.startBackward", "= true, if v_relfric=0 and start of backward sliding [:#(type=Boolean)]",\
 396, false, 0.0,0.0,0.0,0,722)
DeclareVariable("dragForce.locked", "= true, if v_relfric=0 and not sliding [:#(type=Boolean)]",\
 397, false, 0.0,0.0,0.0,0,706)
DeclareVariable("dragForce.Unknown", "Value of mode is not known [:#(type=Integer)]",\
 9, 3, 0.0,0.0,0.0,0,517)
DeclareVariable("dragForce.Free", "Element is not active [:#(type=Integer)]", 10,\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("dragForce.Forward", "v_relfric > 0 (forward sliding) [:#(type=Integer)]",\
 11, 1, 0.0,0.0,0.0,0,517)
DeclareVariable("dragForce.Stuck", "v_relfric = 0 (forward sliding, locked or backward sliding) [:#(type=Integer)]",\
 12, 0, 0.0,0.0,0.0,0,517)
DeclareVariable("dragForce.Backward", "v_relfric < 0 (backward sliding) [:#(type=Integer)]",\
 13, -1, 0.0,0.0,0.0,0,517)
DeclareVariable("dragForce.mode", "Mode of friction (-1: backward sliding, 0: stuck, 1: forward sliding, 2: inactive, 3: unknown) [:#(type=Integer)]",\
 398, 3, -1.0,3.0,0.0,0,660)
DeclareVariable("dragForce.unitAcceleration", "[m/s2]", 14, 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("dragForce.unitForce", "[N]", 15, 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("dragForce.f", "Total drag force [N]", "mass.flange_b.f", -1, 5, 411,\
 0)
DeclareAlias2("dragForce.v", "vehicle velocity [m/s]", "mass.v", 1, 5, 412, 0)
DeclareAlias2("dragForce.der(v)", "der(vehicle velocity) [m/s2]", "mass.der(v)", 1,\
 5, 413, 0)
DeclareAlias2("dragForce.a", "Absolute acceleration of flange [m/s2]", \
"mass.der(v)", 1, 5, 413, 0)
DeclareVariable("dragForce.Sign", "", 399, 0.0, 0.0,0.0,0.0,0,640)
DeclareVariable("dragForce.m", "vehicle mass [kg]", 16, 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("dragForce.rho", "air density [kg/m3|g/cm3]", 7, 1.226, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("dragForce.S", "vehicle cross area [m2]", 8, 6.5, 0.0,0.0,0.0,0,560)
DeclareParameter("dragForce.fc", "rolling friction coefficient", 9, 0.01, \
0.0,0.0,0.0,0,560)
DeclareParameter("dragForce.Cx", "aerodinamic drag coefficient", 10, 0.65, \
0.0,0.0,0.0,0,560)
DeclareVariable("dragForce.A", "", 17, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dragForce.B", "", 18, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dragForce.f_pos[1, 1]", "", 19, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("dragForce.f_pos[1, 2]", "", 20, 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("speedSensor1.flange.s", "Absolute position of flange [m]", \
"powDrag.flange_a.s", 1, 5, 416, 4)
DeclareAlias2("speedSensor1.flange.der(s)", "der(Absolute position of flange) [m/s]",\
 "mass.v", 1, 5, 412, 4)
DeclareVariable("speedSensor1.flange.f", "Cut force directed into flange [N]", 21,\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("speedSensor1.v", "Absolute velocity of flange as output signal [m/s]",\
 "mass.v", 1, 5, 412, 0)
DeclareParameter("battery.QCellNom", "Nominal electric charge [C]", 11, 90000, \
0.0,1E+100,0.0,0,560)
DeclareParameter("battery.ECellMin", "Minimum open source voltage [V]", 12, 3.3,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("battery.ECellMax", "Maximum open source voltage [V]", 13, 4.15,\
 0.0001,1E+100,0.0,0,560)
DeclareParameter("battery.SOCMin", "Minimum state of charge", 14, 0, 0.0,1.0,0.0,\
0,560)
DeclareParameter("battery.SOCMax", "Maximum state of charge", 15, 1, 0.0,1.0,0.0,\
0,560)
DeclareParameter("battery.SOCInit", "Initial state of charge", 16, 0.5, 0.0,1.0,\
0.0,0,560)
DeclareParameter("battery.ICellMax", "Maximum admissible current [A]", 17, 500, \
0.0,1E+100,0.0,0,560)
DeclareParameter("battery.R0Cell", "Serial resistance \"R0\" [Ohm]", 18, 0.00035,\
 0.0,1E+100,0.0,0,560)
DeclareVariable("battery.R1Cell", "Serial resistance \"R1\" [Ohm]", 22, 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("battery.C1Cell", "Capacitance in parallel with R1 [F]", 23, 0.0,\
 0.0,1E+100,0.0,0,513)
DeclareParameter("battery.efficiency", "Charging/discharging energy efficiency",\
 19, 0.9, 0.0,0.99,0.0,0,560)
DeclareParameter("battery.iCellEfficiency", "Charging/discharging current the efficiency refers to [A]",\
 20, 200, 0.0,1E+100,0.0,0,560)
DeclareParameter("battery.ns", "Number of serial connected cells per string [:#(type=Integer)]",\
 21, 100, 0.0,0.0,0.0,0,564)
DeclareParameter("battery.np", "Number of parallel connected strings [:#(type=Integer)]",\
 22, 1, 0.0,0.0,0.0,0,564)
DeclareAlias2("battery.uBat", "[V]", "battery.cDummy.v", 1, 1, 3, 0)
DeclareVariable("battery.powerLoss", "[W]", 419, 0.0, 0.0,0.0,0.0,0,512)
DeclareState("battery.cBattery.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 1, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("battery.cBattery.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("battery.cBattery.p.v", "Potential at the pin [V]", \
"battery.EBattery", 1, 5, 435, 4)
DeclareVariable("battery.cBattery.p.i", "Current flowing into the pin [A]", 420,\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("battery.cBattery.n.v", "Potential at the pin [V]", 24, 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("battery.cBattery.n.i", "Current flowing into the pin [A]", \
"battery.cBattery.p.i", -1, 5, 420, 132)
DeclareAlias2("battery.cBattery.i", "Current flowing from pin p to pin n [A]", \
"battery.cBattery.p.i", 1, 5, 420, 0)
DeclareVariable("battery.cBattery.C", "Capacitance [F]", 25, 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("battery.R0.R", "Resistance at temperature T_ref [Ohm]", 26, 1, \
0.0,0.0,0.0,0,513)
DeclareParameter("battery.R0.T_ref", "Reference temperature [K|degC]", 23, \
300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("battery.R0.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 24, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("battery.R0.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 421, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("battery.R0.p.v", "Potential at the pin [V]", "battery.cDummy.v", 1,\
 1, 3, 4)
DeclareVariable("battery.R0.p.i", "Current flowing into the pin [A]", 422, 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("battery.R0.n.v", "Potential at the pin [V]", 423, 0.0, 0.0,0.0,\
0.0,0,520)
DeclareAlias2("battery.R0.n.i", "Current flowing into the pin [A]", \
"battery.R0.p.i", -1, 5, 422, 132)
DeclareAlias2("battery.R0.i", "Current flowing from pin p to pin n [A]", \
"battery.R0.p.i", 1, 5, 422, 0)
DeclareVariable("battery.R0.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 27, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("battery.R0.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 28, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("battery.R0.LossPower", "Loss power leaving component via heatPort [W]",\
 424, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("battery.R0.T_heatPort", "Temperature of heatPort [K|degC]", \
"battery.R0.T", 1, 5, 28, 0)
DeclareVariable("battery.R0.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 29, 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("battery.Ip.p.v", "Potential at the pin [V]", "battery.R0.n.v", 1,\
 5, 423, 4)
DeclareAlias2("battery.Ip.p.i", "Current flowing into the pin [A]", \
"battery.iBatteryStray", 1, 5, 436, 132)
DeclareVariable("battery.Ip.n.v", "Potential at the pin [V]", 30, 0.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("battery.Ip.n.i", "Current flowing into the pin [A]", \
"battery.iBatteryStray", -1, 5, 436, 132)
DeclareAlias2("battery.Ip.i", "Current flowing from pin p to pin n as input signal [A]",\
 "battery.iBatteryStray", 1, 5, 436, 0)
DeclareAlias2("battery.Ip.v", "Voltage drop between the two pins (= p.v - n.v) [V]",\
 "battery.R0.n.v", 1, 5, 423, 0)
DeclareAlias2("battery.p.v", "Potential at the pin [V]", "battery.cDummy.v", 1, 1,\
 3, 4)
DeclareVariable("battery.p.i", "Current flowing into the pin [A]", 425, 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("battery.n.v", "Potential at the pin [V]", 31, 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("battery.n.i", "Current flowing into the pin [A]", 426, 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("battery.R1.R", "Resistance at temperature T_ref [Ohm]", 32, 1, \
0.0,0.0,0.0,0,513)
DeclareParameter("battery.R1.T_ref", "Reference temperature [K|degC]", 25, \
300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("battery.R1.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 26, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("battery.R1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 427, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("battery.R1.p.v", "Potential at the pin [V]", "battery.R0.n.v", 1,\
 5, 423, 4)
DeclareVariable("battery.R1.p.i", "Current flowing into the pin [A]", 428, 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("battery.R1.n.v", "Potential at the pin [V]", "battery.EBattery", 1,\
 5, 435, 4)
DeclareAlias2("battery.R1.n.i", "Current flowing into the pin [A]", \
"battery.R1.p.i", -1, 5, 428, 132)
DeclareAlias2("battery.R1.i", "Current flowing from pin p to pin n [A]", \
"battery.R1.p.i", 1, 5, 428, 0)
DeclareVariable("battery.R1.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 33, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("battery.R1.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 34, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("battery.R1.LossPower", "Loss power leaving component via heatPort [W]",\
 429, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("battery.R1.T_heatPort", "Temperature of heatPort [K|degC]", \
"battery.R1.T", 1, 5, 34, 0)
DeclareVariable("battery.R1.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 35, 0.0, 0.0,0.0,0.0,0,513)
DeclareState("battery.C1.v", "Voltage drop of the two pins (= p.v - n.v) [V]", 2,\
 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("battery.C1.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("battery.C1.p.v", "Potential at the pin [V]", "battery.R0.n.v", 1,\
 5, 423, 4)
DeclareVariable("battery.C1.p.i", "Current flowing into the pin [A]", 430, 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("battery.C1.n.v", "Potential at the pin [V]", "battery.EBattery", 1,\
 5, 435, 4)
DeclareAlias2("battery.C1.n.i", "Current flowing into the pin [A]", \
"battery.C1.p.i", -1, 5, 430, 132)
DeclareAlias2("battery.C1.i", "Current flowing from pin p to pin n [A]", \
"battery.C1.p.i", 1, 5, 430, 0)
DeclareVariable("battery.C1.C", "Capacitance [F]", 36, 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("battery.SOC", "", 431, 0.0, 0.0,0.0,0.0,0,512)
DeclareState("battery.cDummy.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 3, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("battery.cDummy.der(v)", "der(Voltage drop of the two pins (= p.v - n.v)) [V/s]",\
 3, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("battery.cDummy.p.v", "Potential at the pin [V]", "battery.cDummy.v", 1,\
 1, 3, 4)
DeclareVariable("battery.cDummy.p.i", "Current flowing into the pin [A]", 432, \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("battery.cDummy.n.v", "Potential at the pin [V]", 37, 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("battery.cDummy.n.i", "Current flowing into the pin [A]", \
"battery.cDummy.p.i", -1, 5, 432, 132)
DeclareAlias2("battery.cDummy.i", "Current flowing from pin p to pin n [A]", \
"battery.cDummy.p.i", 1, 5, 432, 0)
DeclareVariable("battery.cDummy.C", "Capacitance [F]", 38, 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("battery.efficiencyMax", "", 39, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("battery.C", "Cell capacitance [F]", 40, 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("battery.k", "", 41, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("battery.IBatteryMax", "Maximum battery current [A]", 42, 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("battery.EBatteryMin", "Minimum battery voltage [V]", 43, 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("battery.EBatteryMax", "Maximum battery voltage [V]", 44, 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("battery.QBatteryNominal", "Battery admissible electric charge [C]",\
 45, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("battery.CBattery", "Battery capacitance [F]", 46, 0.0, 0.0,\
1E+100,0.0,0,2561)
DeclareVariable("battery.R0Battery", "Serial inner resistance R0 of cell package [Ohm]",\
 47, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("battery.R1Battery", "Serial inner resistance R1 of cell package [Ohm]",\
 48, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("battery.Rtot", "[Ohm]", 49, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("battery.RtotCell", "[Ohm]", 50, 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("battery.C1Battery", "Battery series inner capacitance C1 [F]", 51,\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("battery.ECell", "Cell e.m.f. [V]", 433, 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("battery.iCellStray", "Cell stray current [A]", 434, 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("battery.EBattery", "Battery e.m.f. [V]", 435, 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareVariable("battery.iBatteryStray", "Cell parasitic current [A]", 436, 0.0,\
 0.0,0.0,0.0,0,2560)
DeclareAlias2("battery.currentSensor.p.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 1028)
DeclareAlias2("battery.currentSensor.p.i", "Current flowing into the pin [A]", \
"battery.R0.p.i", -1, 5, 422, 1156)
DeclareAlias2("battery.currentSensor.n.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 1028)
DeclareAlias2("battery.currentSensor.n.i", "Current flowing into the pin [A]", \
"battery.R0.p.i", 1, 5, 422, 1156)
DeclareAlias2("battery.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "battery.R0.p.i", -1, 5, 422, 1024)
DeclareVariable("battery.gain.k", "Gain value multiplied with input signal [1]",\
 52, 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("battery.gain.u", "Input signal connector", "battery.R0.p.i", -1, 5,\
 422, 1024)
DeclareVariable("battery.gain.y", "Output signal connector", 437, 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareAlias2("battery.abs1.u", "Connector of Real input signal", \
"battery.gain.y", 1, 5, 437, 1024)
DeclareAlias2("battery.abs1.y", "Connector of Real output signal", \
"battery.iBatteryStray", 1, 5, 436, 1024)
DeclareVariable("battery.abs1.generateEvent", "Choose whether events shall be generated [:#(type=Boolean)]",\
 53, false, 0.0,0.0,0.0,0,2563)
DeclareParameter("drive.powMax", "Maximum mechnical power [W]", 27, 150000.0, \
0.0,0.0,0.0,0,560)
DeclareParameter("drive.tauMax", "Maximum torque [N.m]", 28, 1000, 0.0,0.0,0.0,0,560)
DeclareParameter("drive.uDcNom", "nominal DC voltage [V]", 29, 100, 0.0,0.0,0.0,\
0,560)
DeclareParameter("drive.wMax", "Maximum drive speed [rad/s]", 30, 3000, 0.0,0.0,\
0.0,0,560)
DeclareParameter("drive.J", "Rotor's moment of inertia [kg.m2]", 31, 0.25, \
0.0,0.0,0.0,0,560)
DeclareVariable("drive.mapsOnFile", "= true, if tables are taken from a txt file [:#(type=Boolean)]",\
 54, false, 0.0,0.0,0.0,0,515)
DeclareParameter("drive.effTable[1, 1]", "rows: speeds; columns: torques; both p.u. of max",\
 32, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("drive.effTable[1, 2]", "rows: speeds; columns: torques; both p.u. of max",\
 33, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("drive.effTable[1, 3]", "rows: speeds; columns: torques; both p.u. of max",\
 34, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("drive.effTable[2, 1]", "rows: speeds; columns: torques; both p.u. of max",\
 35, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("drive.effTable[2, 2]", "rows: speeds; columns: torques; both p.u. of max",\
 36, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("drive.effTable[2, 3]", "rows: speeds; columns: torques; both p.u. of max",\
 37, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("drive.effTable[3, 1]", "rows: speeds; columns: torques; both p.u. of max",\
 38, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("drive.effTable[3, 2]", "rows: speeds; columns: torques; both p.u. of max",\
 39, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("drive.effTable[3, 3]", "rows: speeds; columns: torques; both p.u. of max",\
 40, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("drive.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.wSensor.flange.phi", 1, 5, 438, 4)
DeclareAlias2("drive.flange_a.tau", "Cut torque in the flange [N.m]", \
"gear.flange_a.tau", -1, 5, 409, 132)
DeclareVariable("drive.wSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 438, 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.wSensor.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "drive.limTau.w", 1, 5, 439, 4)
DeclareVariable("drive.wSensor.flange.tau", "Cut torque in the flange [N.m]", 55,\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.wSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "drive.limTau.w", 1, 5, 439, 0)
DeclareVariable("drive.limTau.w", "", 439, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.limTau.yH", "", 440, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.limTau.powMax", "Maximum mechanical power [W]", 56, 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.limTau.tauMax", "Maximum torque  [N.m]", 57, 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.limTau.wMax", "Maximum speed [rad/s]", 58, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("drive.limTau.state", "=0 below base speed; =1 before wMax; =2 in w limit, =3 above wMax [:#(type=Integer)]",\
 400, 0, 0.0,0.0,0.0,0,644)
DeclareParameter("drive.limTau.alpha", "fraction of wMax over which the torque is to be brought to zero",\
 41, 0.1, 0.0,0.0,0.0,0,2608)
DeclareVariable("drive.limTau.yL", "", 441, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.toElePow.mapsOnFile", "[:#(type=Boolean)]", 59, false, \
0.0,0.0,0.0,0,515)
DeclareVariable("drive.toElePow.tauMax", "Maximum machine torque [N.m]", 60, 400,\
 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.powMax", "Maximum drive power [W]", 61, 22000, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.wMax", "Maximum machine speed [rad/s]", 62, 650,\
 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.effTable[1, 1]", "", 63, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.effTable[1, 2]", "", 64, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.effTable[1, 3]", "", 65, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.effTable[2, 1]", "", 66, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.effTable[2, 2]", "", 67, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.effTable[2, 3]", "", 68, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.effTable[3, 1]", "", 69, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.effTable[3, 2]", "", 70, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.effTable[3, 3]", "", 71, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.u1", "Connector of Real input signal 1", 442,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.toElePow.toEff.u2", "Connector of Real input signal 2", 443,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.toElePow.toEff.y", "Connector of Real output signal", \
"drive.toElePow.applyEta.eta", 1, 5, 447, 0)
DeclareVariable("drive.toElePow.toEff.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 72, false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.toElePow.toEff.table[1, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 73, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.table[1, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 74, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.table[1, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 75, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.table[2, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 76, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.table[2, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 77, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.table[2, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 78, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.table[3, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 79, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.table[3, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 80, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.table[3, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 81, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("drive.toElePow.toEff.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 42, true, 0.0,0.0,0.0,0,562)
DeclareVariable("drive.toElePow.toEff.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 82, 1, 1.0,6.0,0.0,0,517)
DeclareVariable("drive.toElePow.toEff.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 83, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.toElePow.toEff.verboseExtrapolation", "= true, if warning messages are to be printed if table input is outside the definition range [:#(type=Boolean)]",\
 84, false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.toElePow.toEff.u_min[1]", "Minimum abscissa value defined in table",\
 85, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.u_min[2]", "Minimum abscissa value defined in table",\
 86, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.u_max[1]", "Maximum abscissa value defined in table",\
 87, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.u_max[2]", "Maximum abscissa value defined in table",\
 88, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.toElePow.toEff.tableID.id", "[:#(type=Integer)]", 89, 0, \
0.0,0.0,0.0,0,2565)
DeclareAlias2("drive.toElePow.w", "", "drive.limTau.w", 1, 5, 439, 0)
DeclareVariable("drive.toElePow.tau", "", 444, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.toElePow.elePow", "[W]", "drive.toElePow.applyEta.Pel", 1, 5,\
 449, 0)
DeclareAlias2("drive.toElePow.abs1.u", "Connector of Real input signal", \
"drive.limTau.w", 1, 5, 439, 0)
DeclareVariable("drive.toElePow.abs1.y", "Connector of Real output signal", 445,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.toElePow.abs1.generateEvent", "Choose whether events shall be generated [:#(type=Boolean)]",\
 90, false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive.toElePow.abs2.u", "Connector of Real input signal", \
"drive.toElePow.tau", 1, 5, 444, 0)
DeclareVariable("drive.toElePow.abs2.y", "Connector of Real output signal", 446,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.toElePow.abs2.generateEvent", "Choose whether events shall be generated [:#(type=Boolean)]",\
 91, false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.toElePow.normalizeTau.k", "Gain value multiplied with input signal [1]",\
 92, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.toElePow.normalizeTau.u", "Input signal connector", \
"drive.toElePow.abs2.y", 1, 5, 446, 0)
DeclareAlias2("drive.toElePow.normalizeTau.y", "Output signal connector", \
"drive.toElePow.toEff.u1", 1, 5, 442, 0)
DeclareVariable("drive.toElePow.applyEta.eta", "efficiency", 447, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("drive.toElePow.applyEta.P", "Delivered Mechanical Power", 448, \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.toElePow.applyEta.Pel", "Absorbed Electrical power", 449,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.toElePow.applyEta.Losses", "[W]", 450, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.toElePow.PMOT.u1", "Connector of Real input signal 1", \
"drive.toElePow.tau", 1, 5, 444, 0)
DeclareAlias2("drive.toElePow.PMOT.u2", "Connector of Real input signal 2", \
"drive.limTau.w", 1, 5, 439, 0)
DeclareAlias2("drive.toElePow.PMOT.y", "Connector of Real output signal", \
"drive.toElePow.applyEta.P", 1, 5, 448, 0)
DeclareVariable("drive.toElePow.normalizeSpeed.k", "Gain value multiplied with input signal [1]",\
 93, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.toElePow.normalizeSpeed.u", "Input signal connector", \
"drive.toElePow.abs1.y", 1, 5, 445, 0)
DeclareAlias2("drive.toElePow.normalizeSpeed.y", "Output signal connector", \
"drive.toElePow.toEff.u2", 1, 5, 443, 0)
DeclareVariable("drive.pin_p.v", "Potential at the pin [V]", 94, 0.0, 0.0,0.0,\
0.0,0,521)
DeclareVariable("drive.pin_p.i", "Current flowing into the pin [A]", 451, 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("drive.pin_n.v", "Potential at the pin [V]", "battery.cDummy.v", 1,\
 1, 3, 4)
DeclareAlias2("drive.pin_n.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", -1, 5, 451, 132)
DeclareVariable("drive.constPDC.vNom", "", 95, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("drive.constPDC.Ti", "inner PI follower integral time constant [s]",\
 43, 0.01, 0.0,0.0,0.0,0,560)
DeclareAlias2("drive.constPDC.v", "DC voltage", "battery.cDummy.v", -1, 1, 3, 0)
DeclareAlias2("drive.constPDC.feedback1.u1", "Commanded input", "drive.constPDC.Pref", 1,\
 5, 454, 0)
DeclareVariable("drive.constPDC.feedback1.u2", "Feedback input", 452, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("drive.constPDC.feedback1.y", "", 453, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.constPDC.pin_p.v", "Potential at the pin [V]", 96, 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("drive.constPDC.pin_p.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", 1, 5, 451, 132)
DeclareAlias2("drive.constPDC.pin_n.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareAlias2("drive.constPDC.pin_n.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", -1, 5, 451, 132)
DeclareVariable("drive.constPDC.Pref", "Reference power", 454, 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("drive.constPDC.pSensor.pc.v", "Potential at the pin [V]", 97, \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.constPDC.pSensor.pc.i", "Current flowing into the pin [A]",\
 "drive.pin_p.i", 1, 5, 451, 132)
DeclareVariable("drive.constPDC.pSensor.nc.v", "Potential at the pin [V]", 98, \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.constPDC.pSensor.nc.i", "Current flowing into the pin [A]",\
 "drive.pin_p.i", -1, 5, 451, 132)
DeclareVariable("drive.constPDC.pSensor.pv.v", "Potential at the pin [V]", 99, \
0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.constPDC.pSensor.pv.i", "Current flowing into the pin [A]",\
 100, 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.constPDC.pSensor.nv.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareVariable("drive.constPDC.pSensor.nv.i", "Current flowing into the pin [A]",\
 101, 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.constPDC.pSensor.power", "Instantaneous power as output signal [W]",\
 "drive.constPDC.feedback1.u2", 1, 5, 452, 0)
DeclareVariable("drive.constPDC.pSensor.voltageSensor.p.v", "Potential at the pin [V]",\
 102, 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.constPDC.pSensor.voltageSensor.p.i", "Current flowing into the pin [A]",\
 103, 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.constPDC.pSensor.voltageSensor.n.v", "Potential at the pin [V]",\
 "battery.cDummy.v", 1, 1, 3, 4)
DeclareVariable("drive.constPDC.pSensor.voltageSensor.n.i", "Current flowing into the pin [A]",\
 104, 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.constPDC.pSensor.voltageSensor.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "battery.cDummy.v", -1, 1, 3, 0)
DeclareVariable("drive.constPDC.pSensor.currentSensor.p.v", "Potential at the pin [V]",\
 105, 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.constPDC.pSensor.currentSensor.p.i", "Current flowing into the pin [A]",\
 "drive.pin_p.i", 1, 5, 451, 132)
DeclareVariable("drive.constPDC.pSensor.currentSensor.n.v", "Potential at the pin [V]",\
 106, 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.constPDC.pSensor.currentSensor.n.i", "Current flowing into the pin [A]",\
 "drive.pin_p.i", -1, 5, 451, 132)
DeclareAlias2("drive.constPDC.pSensor.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "drive.pin_p.i", 1, 5, 451, 0)
DeclareAlias2("drive.constPDC.pSensor.product.u1", "Connector of Real input signal 1",\
 "battery.cDummy.v", -1, 1, 3, 0)
DeclareAlias2("drive.constPDC.pSensor.product.u2", "Connector of Real input signal 2",\
 "drive.pin_p.i", 1, 5, 451, 0)
DeclareAlias2("drive.constPDC.pSensor.product.y", "Connector of Real output signal",\
 "drive.constPDC.feedback1.u2", 1, 5, 452, 0)
DeclareParameter("drive.constPDC.varCond.T_ref", "Reference temperature [K|degC]",\
 44, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("drive.constPDC.varCond.alpha", "Temperature coefficient of conductance (G_actual = G/(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 45, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("drive.constPDC.varCond.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "battery.cDummy.v", -1, 1, 3, 0)
DeclareVariable("drive.constPDC.varCond.p.v", "Potential at the pin [V]", 107, \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.constPDC.varCond.p.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", 1, 5, 451, 132)
DeclareAlias2("drive.constPDC.varCond.n.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareAlias2("drive.constPDC.varCond.n.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", -1, 5, 451, 132)
DeclareAlias2("drive.constPDC.varCond.i", "Current flowing from pin p to pin n [A]",\
 "drive.pin_p.i", 1, 5, 451, 0)
DeclareVariable("drive.constPDC.varCond.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 108, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.constPDC.varCond.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 109, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.constPDC.varCond.LossPower", "Loss power leaving component via heatPort [W]",\
 455, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.constPDC.varCond.T_heatPort", "Temperature of heatPort [K|degC]",\
 "drive.constPDC.varCond.T", 1, 5, 109, 0)
DeclareVariable("drive.constPDC.varCond.G_actual", "Actual conductance = G/(1 + alpha*(T_heatPort - T_ref)) [S]",\
 456, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.constPDC.varCond.G", "[S]", "drive.constPDC.integrator1.y", 1,\
 1, 4, 0)
DeclareVariable("drive.constPDC.integrator1.k", "Integrator gain [1]", 110, 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("drive.constPDC.integrator1.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 111, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.constPDC.integrator1.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 112, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.constPDC.integrator1.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 113, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("drive.constPDC.integrator1.y_start", "Initial or guess value of output (= state)",\
 46, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("drive.constPDC.integrator1.u", "Connector of Real input signal", \
"drive.constPDC.feedback1.y", 1, 5, 453, 0)
DeclareState("drive.constPDC.integrator1.y", "Connector of Real output signal", 4,\
 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("drive.constPDC.integrator1.der(y)", "der(Connector of Real output signal)",\
 4, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.constPDC.integrator1.local_reset", "[:#(type=Boolean)]", 114,\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.constPDC.integrator1.local_set", "", 115, 0, 0.0,0.0,0.0,\
0,1537)
DeclareAlias2("drive.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.wSensor.flange.phi", 1, 5, 438, 4)
DeclareAlias2("drive.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"drive.toElePow.tau", 1, 5, 444, 132)
DeclareAlias2("drive.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.wSensor.flange.phi", 1, 5, 438, 4)
DeclareAlias2("drive.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
"gear.flange_a.tau", -1, 5, 409, 132)
DeclareVariable("drive.inertia.J", "Moment of inertia [kg.m2]", 116, 1, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 117, 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("drive.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "drive.wSensor.flange.phi", 1, 5, 438, 0)
DeclareAlias2("drive.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "drive.limTau.w", 1, 5, 439, 0)
DeclareVariable("drive.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 457, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 458, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "drive.inertia.der(w)", 1, 5, 458, 0)
DeclareVariable("drive.torque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 118, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("drive.torque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.wSensor.flange.phi", 1, 5, 438, 4)
DeclareAlias2("drive.torque.flange.tau", "Cut torque in the flange [N.m]", \
"drive.toElePow.tau", -1, 5, 444, 132)
DeclareVariable("drive.torque.phi_support", "Absolute angle of support flange [rad|deg]",\
 119, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("drive.torque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "drive.toElePow.tau", 1, 5, 444, 0)
DeclareParameter("drive.gain.k", "Gain value multiplied with input signal [1]", 47,\
 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("drive.gain.u", "Input signal connector", "drive.toElePow.applyEta.Pel", 1,\
 5, 449, 0)
DeclareAlias2("drive.gain.y", "Output signal connector", "drive.constPDC.Pref", 1,\
 5, 454, 0)
DeclareAlias2("drive.powSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.wSensor.flange.phi", 1, 5, 438, 4)
DeclareAlias2("drive.powSensor.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "drive.limTau.w", 1, 5, 439, 4)
DeclareAlias2("drive.powSensor.flange_a.tau", "Cut torque in the flange [N.m]", \
"gear.flange_a.tau", 1, 5, 409, 132)
DeclareAlias2("drive.powSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.wSensor.flange.phi", 1, 5, 438, 4)
DeclareAlias2("drive.powSensor.flange_b.tau", "Cut torque in the flange [N.m]", \
"gear.flange_a.tau", -1, 5, 409, 132)
DeclareVariable("drive.powSensor.power", "Power in flange flange_a as output signal [W]",\
 459, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.variableLimiter.u", "Connector of Real input signal", \
"drive.tauRef", 1, 5, 460, 0)
DeclareAlias2("drive.variableLimiter.y", "Connector of Real output signal", \
"drive.toElePow.tau", 1, 5, 444, 0)
DeclareVariable("drive.variableLimiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 120, false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.variableLimiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.VariableLimiterHomotopy)]",\
 121, 2, 1.0,3.0,0.0,0,517)
DeclareParameter("drive.variableLimiter.ySimplified", "Fixed value of output in simplified model",\
 48, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("drive.variableLimiter.limit1", "Connector of Real input signal used as maximum of input u",\
 "drive.limTau.yH", 1, 5, 440, 0)
DeclareAlias2("drive.variableLimiter.limit2", "Connector of Real input signal used as minimum of input u",\
 "drive.limTau.yL", 1, 5, 441, 0)
DeclareAlias2("drive.variableLimiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "drive.tauRef", 1, 5, 460, 1024)
DeclareVariable("drive.tauRef", "(positive when motor peration)", 460, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("gsPow.pc.v", "Potential at the pin [V]", "battery.cDummy.v", 1, 1,\
 3, 4)
DeclareVariable("gsPow.pc.i", "Current flowing into the pin [A]", 461, 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("gsPow.nc.v", "Potential at the pin [V]", "battery.cDummy.v", 1, 1,\
 3, 4)
DeclareAlias2("gsPow.nc.i", "Current flowing into the pin [A]", "gsPow.pc.i", -1,\
 5, 461, 132)
DeclareAlias2("gsPow.pv.v", "Potential at the pin [V]", "battery.cDummy.v", 1, 1,\
 3, 4)
DeclareVariable("gsPow.pv.i", "Current flowing into the pin [A]", 122, 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("gsPow.nv.v", "Potential at the pin [V]", 123, 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("gsPow.nv.i", "Current flowing into the pin [A]", 124, 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("gsPow.power", "Instantaneous power as output signal [W]", 462, \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("gsPow.voltageSensor.p.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareVariable("gsPow.voltageSensor.p.i", "Current flowing into the pin [A]", 125,\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("gsPow.voltageSensor.n.v", "Potential at the pin [V]", 126, 0.0,\
 0.0,0.0,0.0,0,521)
DeclareVariable("gsPow.voltageSensor.n.i", "Current flowing into the pin [A]", 127,\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("gsPow.voltageSensor.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "battery.cDummy.v", 1, 1, 3, 0)
DeclareAlias2("gsPow.currentSensor.p.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareAlias2("gsPow.currentSensor.p.i", "Current flowing into the pin [A]", \
"gsPow.pc.i", 1, 5, 461, 132)
DeclareAlias2("gsPow.currentSensor.n.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareAlias2("gsPow.currentSensor.n.i", "Current flowing into the pin [A]", \
"gsPow.pc.i", -1, 5, 461, 132)
DeclareAlias2("gsPow.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "gsPow.pc.i", 1, 5, 461, 0)
DeclareAlias2("gsPow.product.u1", "Connector of Real input signal 1", \
"battery.cDummy.v", 1, 1, 3, 0)
DeclareAlias2("gsPow.product.u2", "Connector of Real input signal 2", \
"gsPow.pc.i", 1, 5, 461, 0)
DeclareAlias2("gsPow.product.y", "Connector of Real output signal", \
"gsPow.power", 1, 5, 462, 0)
DeclareParameter("ems.tauPowFilt", "power filter time constant", 49, 300, \
0.0,0.0,0.0,0,560)
DeclareParameter("ems.powLow", "hysteresis control lower limit", 50, 30000.0, \
0.0,0.0,0.0,0,560)
DeclareParameter("ems.powHigh", "hysteresis control higher limit", 51, 60000.0, \
0.0,0.0,0.0,0,560)
DeclareParameter("ems.powPerSoc", "SOC loop gain", 52, 300000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("ems.powMax", "Max power that can be requested as output", 53, \
200000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("ems.socRef", "", 54, 0.6, 0.0,0.0,0.0,0,560)
DeclareVariable("ems.limiter.uMax", "Upper limits of input signals", 128, 1, \
0.0,0.0,0.0,0,513)
DeclareParameter("ems.limiter.uMin", "Lower limits of input signals", 55, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("ems.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 129, false, 0.0,0.0,0.0,0,515)
DeclareVariable("ems.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 130, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("ems.limiter.u", "Connector of Real input signal", 463, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("ems.limiter.y", "Connector of Real output signal", 464, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("ems.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "ems.limiter.u", 1, 5, 463, 1024)
DeclareAlias2("ems.fbSOC.u1", "Commanded input", "ems.socRef_.k", 1, 5, 131, 0)
DeclareAlias2("ems.fbSOC.u2", "Feedback input", "battery.SOC", 1, 5, 431, 0)
DeclareVariable("ems.fbSOC.y", "", 465, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("ems.socRef_.k", "Constant output value", 131, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("ems.socRef_.y", "Connector of Real output signal", \
"ems.socRef_.k", 1, 5, 131, 0)
DeclareVariable("ems.socErrToPow.k", "Gain value multiplied with input signal [1]",\
 132, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("ems.socErrToPow.u", "Input signal connector", "ems.fbSOC.y", 1, 5,\
 465, 0)
DeclareVariable("ems.socErrToPow.y", "Output signal connector", 466, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("ems.add.u1", "Connector of Real input signal 1", "ems.powFilt.y", 1,\
 1, 5, 0)
DeclareAlias2("ems.add.u2", "Connector of Real input signal 2", "ems.socErrToPow.y", 1,\
 5, 466, 0)
DeclareAlias2("ems.add.y", "Connector of Real output signal", "ems.limiter.u", 1,\
 5, 463, 0)
DeclareParameter("ems.add.k1", "Gain of input signal 1", 56, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("ems.add.k2", "Gain of input signal 2", 57, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("ems.edPow", "", 467, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("ems.soc", "", "battery.SOC", 1, 5, 431, 0)
DeclareAlias2("ems.powSwitch.u1", "Connector of first Real input signal", \
"ems.limiter.y", 1, 5, 464, 0)
DeclareAlias2("ems.powSwitch.u2", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "ems.powHyst.y", 1, 5, 401, 65)
DeclareAlias2("ems.powSwitch.u3", "Connector of second Real input signal", \
"ems.zero.k", 1, 7, 59, 0)
DeclareAlias2("ems.powSwitch.y", "Connector of Real output signal", \
"ems.pcPowReq", 1, 5, 468, 0)
DeclareVariable("ems.powHyst.uLow", "If y=true and u<uLow, switch to y=false", 133,\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("ems.powHyst.uHigh", "If y=false and u>uHigh, switch to y=true",\
 134, 1, 0.0,0.0,0.0,0,513)
DeclareParameter("ems.powHyst.pre_y_start", "Value of pre(y) at initial time [:#(type=Boolean)]",\
 58, false, 0.0,0.0,0.0,0,562)
DeclareAlias2("ems.powHyst.u", "", "ems.limiter.y", 1, 5, 464, 0)
DeclareVariable("ems.powHyst.y", "[:#(type=Boolean)]", 401, false, 0.0,0.0,0.0,0,642)
DeclareParameter("ems.zero.k", "Constant output value", 59, 0.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("ems.zero.y", "Connector of Real output signal", "ems.zero.k", 1, 7,\
 59, 0)
DeclareAlias2("ems.on", "[:#(type=Boolean)]", "ems.powHyst.y", 1, 5, 401, 65)
DeclareVariable("ems.pcPowReq", "[|kW]", 468, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("ems.powFilt.k", "Gain [1]", 60, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("ems.powFilt.T", "Time Constant [s]", 135, 1, 0.0,0.0,0.0,0,513)
DeclareVariable("ems.powFilt.initType", "Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 136, 1, 1.0,4.0,0.0,0,517)
DeclareParameter("ems.powFilt.y_start", "Initial or guess value of output (= state)",\
 61, 20000.0, 0.0,0.0,0.0,0,560)
DeclareAlias2("ems.powFilt.u", "Connector of Real input signal", "ems.edPow", 1,\
 5, 467, 0)
DeclareState("ems.powFilt.y", "Connector of Real output signal", 5, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("ems.powFilt.der(y)", "der(Connector of Real output signal)", 5,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("genset.gsRatio", "IdealGear speed reduction factor", 62, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("genset.maxGenW", "[rad/s]", 63, 300, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.maxTau", "Max mechanical torque [N.m]", 64, 500, \
0.0,0.0,0.0,0,560)
DeclareParameter("genset.maxPow", "Max mechanical power [W]", 65, 45000, \
0.0,0.0,0.0,0,560)
DeclareParameter("genset.wIceStart", "[rad/s]", 66, 300, 0.0,0.0,0.0,0,560)
DeclareVariable("genset.speedSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 469, 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("genset.speedSensor.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "genset.mbIce.inertia.w", 1, 5, 504, 4)
DeclareVariable("genset.speedSensor.flange.tau", "Cut torque in the flange [N.m]",\
 137, 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("genset.speedSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareVariable("genset.idealGear.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 138, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("genset.idealGear.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.speedSensor.flange.phi", 1, 5, 469, 4)
DeclareVariable("genset.idealGear.flange_a.tau", "Cut torque in the flange [N.m]",\
 470, 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("genset.idealGear.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 4)
DeclareVariable("genset.idealGear.flange_b.tau", "Cut torque in the flange [N.m]",\
 471, 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("genset.idealGear.phi_support", "Absolute angle of support flange [rad|deg]",\
 139, 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("genset.idealGear.ratio", "Transmission ratio (flange_a.phi/flange_b.phi)",\
 140, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("genset.idealGear.phi_a", "Angle between left shaft flange and support [rad|deg]",\
 "genset.speedSensor.flange.phi", 1, 5, 469, 0)
DeclareAlias2("genset.idealGear.phi_b", "Angle between right shaft flange and support [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 0)
DeclareAlias2("genset.ON", "when true engine is ON [:#(type=Boolean)]", \
"ems.powHyst.y", 1, 5, 401, 65)
DeclareState("genset.IcePow.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 6, 0.0, 0.0,0.0,0.0,0,568)
DeclareDerivative("genset.IcePow.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 6, 0.0, 0.0,0.0,0.0,0,8712)
DeclareAlias2("genset.IcePow.flange_a.tau", "Cut torque in the flange [N.m]", \
"genset.idealGear.flange_b.tau", -1, 5, 471, 132)
DeclareAlias2("genset.IcePow.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 4)
DeclareAlias2("genset.IcePow.flange_b.tau", "Cut torque in the flange [N.m]", \
"genset.idealGear.flange_b.tau", 1, 5, 471, 132)
DeclareVariable("genset.IcePow.power", "Power in flange flange_a as output signal [W]",\
 472, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.powRef", "Reference genset power [W]", "ems.pcPowReq", 1, 5,\
 468, 0)
DeclareAlias2("genset.pin_p.v", "Potential at the pin [V]", "battery.cDummy.v", 1,\
 1, 3, 4)
DeclareAlias2("genset.pin_p.i", "Current flowing into the pin [A]", "gsPow.pc.i", -1,\
 5, 461, 132)
DeclareVariable("genset.pin_n.v", "Potential at the pin [V]", 141, 0.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("genset.pin_n.i", "Current flowing into the pin [A]", "gsPow.pc.i", 1,\
 5, 461, 132)
DeclareParameter("genset.limiter.uMax", "Upper limits of input signals", 67, \
1E+60, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.limiter.uMin", "Lower limits of input signals", 68, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("genset.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 142, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 143, 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("genset.limiter.u", "Connector of Real input signal", \
"ems.pcPowReq", 1, 5, 468, 0)
DeclareVariable("genset.limiter.y", "Connector of Real output signal", 473, 0.0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "ems.pcPowReq", 1, 5, 468, 1024)
DeclareParameter("genset.gms.tauMax", "maximum torque internally exchanged by the two machines",\
 69, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.throttlePerWerr", "speed controller gain (throttle per rad/s)",\
 70, 0.1, 0.0,0.0,0.0,0,560)
DeclareVariable("genset.gms.tablesOnFile", "[:#(type=Boolean)]", 144, true, \
0.0,0.0,0.0,0,515)
DeclareParameter("genset.gms.optiTable[1, 1]", "first row: speed, 1st column: torque, body: sp. consumption",\
 71, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[1, 2]", "first row: speed, 1st column: torque, body: sp. consumption",\
 72, 800, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[2, 1]", "first row: speed, 1st column: torque, body: sp. consumption",\
 73, 20000, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[2, 2]", "first row: speed, 1st column: torque, body: sp. consumption",\
 74, 850, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[3, 1]", "first row: speed, 1st column: torque, body: sp. consumption",\
 75, 40000, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[3, 2]", "first row: speed, 1st column: torque, body: sp. consumption",\
 76, 1100, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[4, 1]", "first row: speed, 1st column: torque, body: sp. consumption",\
 77, 60000, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[4, 2]", "first row: speed, 1st column: torque, body: sp. consumption",\
 78, 1250, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[5, 1]", "first row: speed, 1st column: torque, body: sp. consumption",\
 79, 80000, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[5, 2]", "first row: speed, 1st column: torque, body: sp. consumption",\
 80, 1280, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[6, 1]", "first row: speed, 1st column: torque, body: sp. consumption",\
 81, 100000, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[6, 2]", "first row: speed, 1st column: torque, body: sp. consumption",\
 82, 1340, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[7, 1]", "first row: speed, 1st column: torque, body: sp. consumption",\
 83, 120000, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[7, 2]", "first row: speed, 1st column: torque, body: sp. consumption",\
 84, 1400, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[8, 1]", "first row: speed, 1st column: torque, body: sp. consumption",\
 85, 140000, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[8, 2]", "first row: speed, 1st column: torque, body: sp. consumption",\
 86, 1650, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[9, 1]", "first row: speed, 1st column: torque, body: sp. consumption",\
 87, 160000, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.optiTable[9, 2]", "first row: speed, 1st column: torque, body: sp. consumption",\
 88, 2130, 0.0,0.0,0.0,0,560)
DeclareVariable("genset.gms.optiSpeed.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 145, 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("genset.gms.optiSpeed.u[1]", "Connector of Real input signals", \
"genset.limiter.y", 1, 5, 473, 0)
DeclareVariable("genset.gms.optiSpeed.y[1]", "Connector of Real output signals",\
 474, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gms.optiSpeed.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 146, true, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.gms.optiSpeed.table[1, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 147, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[1, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 148, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[2, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 149, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[2, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 150, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[3, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 151, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[3, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 152, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[4, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 153, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[4, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 154, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[5, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 155, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[5, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 156, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[6, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 157, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[6, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 158, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[7, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 159, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[7, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 160, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[8, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 161, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[8, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 162, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[9, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 163, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.table[9, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 164, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("genset.gms.optiSpeed.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 89, true, 0.0,0.0,0.0,0,562)
DeclareParameter("genset.gms.optiSpeed.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 90, 2, 0.0,0.0,0.0,0,564)
DeclareVariable("genset.gms.optiSpeed.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 165, 2, 1.0,6.0,0.0,0,517)
DeclareVariable("genset.gms.optiSpeed.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 166, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("genset.gms.optiSpeed.verboseExtrapolation", "= true, if warning messages are to be printed if table input is outside the definition range [:#(type=Boolean)]",\
 167, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.gms.optiSpeed.u_min", "Minimum abscissa value defined in table",\
 168, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.u_max", "Maximum abscissa value defined in table",\
 169, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.optiSpeed.tableID.id", "[:#(type=Integer)]", 170, 0,\
 0.0,0.0,0.0,0,2565)
DeclareAlias2("genset.gms.division.u1", "Connector of Real input signal 1", \
"genset.limiter.y", 1, 5, 473, 0)
DeclareVariable("genset.gms.division.u2", "Connector of Real input signal 2", 475,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gms.division.y", "Connector of Real output signal", 476,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.gms.Wmecc", "", "genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareAlias2("genset.gms.pRef", "", "genset.limiter.y", 1, 5, 473, 0)
DeclareVariable("genset.gms.tRef", "Torque request (positive when ICE delivers power)",\
 477, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gms.throttle", "", 478, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gms.feedback.u1", "Commanded input", 479, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("genset.gms.feedback.u2", "Feedback input", 480, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("genset.gms.feedback.y", "", 481, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gms.gain.k", "Gain value multiplied with input signal [1]",\
 171, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("genset.gms.gain.u", "Input signal connector", "genset.gms.feedback.y", 1,\
 5, 481, 0)
DeclareAlias2("genset.gms.gain.y", "Output signal connector", "genset.gms.throttle", 1,\
 5, 478, 0)
DeclareAlias2("genset.gms.to_rpm.u", "Connector of Real input signal to be converted [rad/s]",\
 "genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareAlias2("genset.gms.to_rpm.y", "Connector of Real output signal containing input signal u in another unit [rev/min]",\
 "genset.gms.feedback.u2", 1, 5, 480, 0)
DeclareAlias2("genset.gms.on", "[:#(type=Boolean)]", "ems.powHyst.y", 1, 5, 401,\
 65)
DeclareAlias2("genset.gms.switch1.u1", "Connector of first Real input signal", \
"genset.gms.optiSpeed.y[1]", 1, 5, 474, 0)
DeclareAlias2("genset.gms.switch1.u2", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "ems.powHyst.y", 1, 5, 401, 65)
DeclareAlias2("genset.gms.switch1.u3", "Connector of second Real input signal", \
"genset.gms.zero.k", 1, 7, 91, 0)
DeclareAlias2("genset.gms.switch1.y", "Connector of Real output signal", \
"genset.gms.feedback.u1", 1, 5, 479, 0)
DeclareParameter("genset.gms.zero.k", "Constant output value", 91, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("genset.gms.zero.y", "Connector of Real output signal", \
"genset.gms.zero.k", 1, 7, 91, 0)
DeclareParameter("genset.gms.limMinW.uMax", "Upper limits of input signals", 92,\
 1000000000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gms.limMinW.uMin", "Lower limits of input signals", 93,\
 10, 0.0,0.0,0.0,0,560)
DeclareVariable("genset.gms.limMinW.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 172, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.gms.limMinW.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 173, 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("genset.gms.limMinW.u", "Connector of Real input signal", \
"genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareAlias2("genset.gms.limMinW.y", "Connector of Real output signal", \
"genset.gms.division.u2", 1, 5, 475, 0)
DeclareAlias2("genset.gms.limMinW.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "genset.mbIce.inertia.w", 1, 5, 504, 1024)
DeclareVariable("genset.gms.maxTau.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 174, 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("genset.gms.maxTau.u[1]", "Connector of Real input signals", \
"genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareVariable("genset.gms.maxTau.y[1]", "Connector of Real output signals", 482,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gms.maxTau.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 175, true, 0.0,0.0,0.0,0,515)
DeclareParameter("genset.gms.maxTau.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 94, true, 0.0,0.0,0.0,0,562)
DeclareParameter("genset.gms.maxTau.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 95, 2, 0.0,0.0,0.0,0,564)
DeclareVariable("genset.gms.maxTau.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 176, 1, 1.0,6.0,0.0,0,517)
DeclareVariable("genset.gms.maxTau.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 177, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("genset.gms.maxTau.verboseExtrapolation", "= true, if warning messages are to be printed if table input is outside the definition range [:#(type=Boolean)]",\
 178, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.gms.maxTau.u_min", "Minimum abscissa value defined in table",\
 179, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.maxTau.u_max", "Maximum abscissa value defined in table",\
 180, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gms.maxTau.tableID.id", "[:#(type=Integer)]", 181, 0, \
0.0,0.0,0.0,0,2565)
DeclareParameter("genset.gms.gain1.k", "Gain value multiplied with input signal [1]",\
 96, -1, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.gms.gain1.u", "Input signal connector", "genset.gms.maxTau.y[1]", 1,\
 5, 482, 0)
DeclareVariable("genset.gms.gain1.y", "Output signal connector", 483, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("genset.gms.tauLimiter.u", "Connector of Real input signal", \
"genset.gms.division.y", 1, 5, 476, 0)
DeclareAlias2("genset.gms.tauLimiter.y", "Connector of Real output signal", \
"genset.gms.tRef", 1, 5, 477, 0)
DeclareVariable("genset.gms.tauLimiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 182, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.gms.tauLimiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.VariableLimiterHomotopy)]",\
 183, 2, 1.0,3.0,0.0,0,517)
DeclareParameter("genset.gms.tauLimiter.ySimplified", "Fixed value of output in simplified model",\
 97, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.gms.tauLimiter.limit1", "Connector of Real input signal used as maximum of input u",\
 "genset.gms.maxTau.y[1]", 1, 5, 482, 0)
DeclareAlias2("genset.gms.tauLimiter.limit2", "Connector of Real input signal used as minimum of input u",\
 "genset.gms.gain1.y", 1, 5, 483, 0)
DeclareAlias2("genset.gms.tauLimiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "genset.gms.division.y", 1, 5, 476, 1024)
DeclareAlias2("genset.gms.realExpression.y", "Value of Real output", \
"genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareVariable("genset.gen.powMax", "Maximum mechnical power [W]", 184, 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.tauMax", "Maximum torque [N.m]", 185, 0.0, 0.0,0.0,\
0.0,0,513)
DeclareParameter("genset.gen.uDcNom", "nominal DC voltage [V]", 98, 100, \
0.0,0.0,0.0,0,560)
DeclareVariable("genset.gen.wMax", "Maximum drive speed [rad/s]", 186, 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("genset.gen.J", "Rotor's moment of inertia [kg.m2]", 99, 0.25, \
0.0,0.0,0.0,0,560)
DeclareVariable("genset.gen.mapsOnFile", "= true, if tables are taken from a txt file [:#(type=Boolean)]",\
 187, true, 0.0,0.0,0.0,0,515)
DeclareParameter("genset.gen.effTable[1, 1]", "rows: speeds; columns: torques; both p.u. of max",\
 100, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gen.effTable[1, 2]", "rows: speeds; columns: torques; both p.u. of max",\
 101, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gen.effTable[1, 3]", "rows: speeds; columns: torques; both p.u. of max",\
 102, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gen.effTable[2, 1]", "rows: speeds; columns: torques; both p.u. of max",\
 103, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gen.effTable[2, 2]", "rows: speeds; columns: torques; both p.u. of max",\
 104, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gen.effTable[2, 3]", "rows: speeds; columns: torques; both p.u. of max",\
 105, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gen.effTable[3, 1]", "rows: speeds; columns: torques; both p.u. of max",\
 106, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gen.effTable[3, 2]", "rows: speeds; columns: torques; both p.u. of max",\
 107, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.gen.effTable[3, 3]", "rows: speeds; columns: torques; both p.u. of max",\
 108, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.gen.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 4)
DeclareAlias2("genset.gen.flange_a.tau", "Cut torque in the flange [N.m]", \
"genset.idealGear.flange_b.tau", -1, 5, 471, 132)
DeclareAlias2("genset.gen.wSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 4)
DeclareAlias2("genset.gen.wSensor.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "genset.gen.limTau.w", 1, 5, 484, 4)
DeclareVariable("genset.gen.wSensor.flange.tau", "Cut torque in the flange [N.m]",\
 188, 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("genset.gen.wSensor.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "genset.gen.limTau.w", 1, 5, 484, 0)
DeclareVariable("genset.gen.limTau.w", "", 484, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.limTau.yH", "", 485, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.limTau.powMax", "Maximum mechanical power [W]", 189,\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.limTau.tauMax", "Maximum torque  [N.m]", 190, 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.limTau.wMax", "Maximum speed [rad/s]", 191, 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.limTau.state", "=0 below base speed; =1 before wMax; =2 in w limit, =3 above wMax [:#(type=Integer)]",\
 402, 0, 0.0,0.0,0.0,0,644)
DeclareParameter("genset.gen.limTau.alpha", "fraction of wMax over which the torque is to be brought to zero",\
 109, 0.1, 0.0,0.0,0.0,0,2608)
DeclareVariable("genset.gen.limTau.yL", "", 486, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.toElePow.mapsOnFile", "[:#(type=Boolean)]", 192, \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.gen.toElePow.tauMax", "Maximum machine torque [N.m]", 193,\
 400, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.powMax", "Maximum drive power [W]", 194, 22000,\
 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.wMax", "Maximum machine speed [rad/s]", 195,\
 650, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.effTable[1, 1]", "", 196, 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("genset.gen.toElePow.effTable[1, 2]", "", 197, 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("genset.gen.toElePow.effTable[1, 3]", "", 198, 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("genset.gen.toElePow.effTable[2, 1]", "", 199, 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("genset.gen.toElePow.effTable[2, 2]", "", 200, 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("genset.gen.toElePow.effTable[2, 3]", "", 201, 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("genset.gen.toElePow.effTable[3, 1]", "", 202, 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("genset.gen.toElePow.effTable[3, 2]", "", 203, 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("genset.gen.toElePow.effTable[3, 3]", "", 204, 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("genset.gen.toElePow.toEff.u1", "Connector of Real input signal 1",\
 487, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.toElePow.toEff.u2", "Connector of Real input signal 2",\
 488, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.gen.toElePow.toEff.y", "Connector of Real output signal", \
"genset.gen.toElePow.applyEta.eta", 1, 5, 492, 0)
DeclareVariable("genset.gen.toElePow.toEff.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 205, true, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.gen.toElePow.toEff.table[1, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 206, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.table[1, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 207, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.table[1, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 208, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.table[2, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 209, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.table[2, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 210, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.table[2, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 211, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.table[3, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 212, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.table[3, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 213, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.table[3, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 214, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("genset.gen.toElePow.toEff.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 110, true, 0.0,0.0,0.0,0,562)
DeclareVariable("genset.gen.toElePow.toEff.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 215, 1, 1.0,6.0,0.0,0,517)
DeclareVariable("genset.gen.toElePow.toEff.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 216, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("genset.gen.toElePow.toEff.verboseExtrapolation", \
"= true, if warning messages are to be printed if table input is outside the definition range [:#(type=Boolean)]",\
 217, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.gen.toElePow.toEff.u_min[1]", "Minimum abscissa value defined in table",\
 218, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.u_min[2]", "Minimum abscissa value defined in table",\
 219, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.u_max[1]", "Maximum abscissa value defined in table",\
 220, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.u_max[2]", "Maximum abscissa value defined in table",\
 221, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.toElePow.toEff.tableID.id", "[:#(type=Integer)]", 222,\
 0, 0.0,0.0,0.0,0,2565)
DeclareAlias2("genset.gen.toElePow.w", "", "genset.gen.limTau.w", 1, 5, 484, 0)
DeclareVariable("genset.gen.toElePow.tau", "", 489, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.gen.toElePow.elePow", "[W]", "genset.gen.toElePow.applyEta.Pel", 1,\
 5, 494, 0)
DeclareAlias2("genset.gen.toElePow.abs1.u", "Connector of Real input signal", \
"genset.gen.limTau.w", 1, 5, 484, 0)
DeclareVariable("genset.gen.toElePow.abs1.y", "Connector of Real output signal",\
 490, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.toElePow.abs1.generateEvent", "Choose whether events shall be generated [:#(type=Boolean)]",\
 223, false, 0.0,0.0,0.0,0,515)
DeclareAlias2("genset.gen.toElePow.abs2.u", "Connector of Real input signal", \
"genset.gen.toElePow.tau", 1, 5, 489, 0)
DeclareVariable("genset.gen.toElePow.abs2.y", "Connector of Real output signal",\
 491, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.toElePow.abs2.generateEvent", "Choose whether events shall be generated [:#(type=Boolean)]",\
 224, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.gen.toElePow.normalizeTau.k", "Gain value multiplied with input signal [1]",\
 225, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("genset.gen.toElePow.normalizeTau.u", "Input signal connector", \
"genset.gen.toElePow.abs2.y", 1, 5, 491, 0)
DeclareAlias2("genset.gen.toElePow.normalizeTau.y", "Output signal connector", \
"genset.gen.toElePow.toEff.u1", 1, 5, 487, 0)
DeclareVariable("genset.gen.toElePow.applyEta.eta", "efficiency", 492, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.toElePow.applyEta.P", "Delivered Mechanical Power", 493,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.toElePow.applyEta.Pel", "Absorbed Electrical power",\
 494, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.toElePow.applyEta.Losses", "[W]", 495, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("genset.gen.toElePow.PMOT.u1", "Connector of Real input signal 1",\
 "genset.gen.toElePow.tau", 1, 5, 489, 0)
DeclareAlias2("genset.gen.toElePow.PMOT.u2", "Connector of Real input signal 2",\
 "genset.gen.limTau.w", 1, 5, 484, 0)
DeclareAlias2("genset.gen.toElePow.PMOT.y", "Connector of Real output signal", \
"genset.gen.toElePow.applyEta.P", 1, 5, 493, 0)
DeclareVariable("genset.gen.toElePow.normalizeSpeed.k", "Gain value multiplied with input signal [1]",\
 226, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("genset.gen.toElePow.normalizeSpeed.u", "Input signal connector", \
"genset.gen.toElePow.abs1.y", 1, 5, 490, 0)
DeclareAlias2("genset.gen.toElePow.normalizeSpeed.y", "Output signal connector",\
 "genset.gen.toElePow.toEff.u2", 1, 5, 488, 0)
DeclareVariable("genset.gen.pin_p.v", "Potential at the pin [V]", 227, 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("genset.gen.pin_p.i", "Current flowing into the pin [A]", \
"gsPow.pc.i", 1, 5, 461, 132)
DeclareAlias2("genset.gen.pin_n.v", "Potential at the pin [V]", "battery.cDummy.v", 1,\
 1, 3, 4)
DeclareAlias2("genset.gen.pin_n.i", "Current flowing into the pin [A]", \
"gsPow.pc.i", -1, 5, 461, 132)
DeclareVariable("genset.gen.constPDC.vNom", "", 228, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("genset.gen.constPDC.Ti", "inner PI follower integral time constant [s]",\
 111, 0.01, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.gen.constPDC.v", "DC voltage", "battery.cDummy.v", -1, 1, 3,\
 0)
DeclareAlias2("genset.gen.constPDC.feedback1.u1", "Commanded input", \
"genset.gen.constPDC.Pref", 1, 5, 498, 0)
DeclareVariable("genset.gen.constPDC.feedback1.u2", "Feedback input", 496, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.constPDC.feedback1.y", "", 497, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.constPDC.pin_p.v", "Potential at the pin [V]", 229, \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("genset.gen.constPDC.pin_p.i", "Current flowing into the pin [A]",\
 "gsPow.pc.i", 1, 5, 461, 132)
DeclareAlias2("genset.gen.constPDC.pin_n.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareAlias2("genset.gen.constPDC.pin_n.i", "Current flowing into the pin [A]",\
 "gsPow.pc.i", -1, 5, 461, 132)
DeclareVariable("genset.gen.constPDC.Pref", "Reference power", 498, 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.constPDC.pSensor.pc.v", "Potential at the pin [V]", 230,\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("genset.gen.constPDC.pSensor.pc.i", "Current flowing into the pin [A]",\
 "gsPow.pc.i", 1, 5, 461, 132)
DeclareVariable("genset.gen.constPDC.pSensor.nc.v", "Potential at the pin [V]", 231,\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("genset.gen.constPDC.pSensor.nc.i", "Current flowing into the pin [A]",\
 "gsPow.pc.i", -1, 5, 461, 132)
DeclareVariable("genset.gen.constPDC.pSensor.pv.v", "Potential at the pin [V]", 232,\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("genset.gen.constPDC.pSensor.pv.i", "Current flowing into the pin [A]",\
 233, 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("genset.gen.constPDC.pSensor.nv.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareVariable("genset.gen.constPDC.pSensor.nv.i", "Current flowing into the pin [A]",\
 234, 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("genset.gen.constPDC.pSensor.power", "Instantaneous power as output signal [W]",\
 "genset.gen.constPDC.feedback1.u2", 1, 5, 496, 0)
DeclareVariable("genset.gen.constPDC.pSensor.voltageSensor.p.v", \
"Potential at the pin [V]", 235, 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("genset.gen.constPDC.pSensor.voltageSensor.p.i", \
"Current flowing into the pin [A]", 236, 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("genset.gen.constPDC.pSensor.voltageSensor.n.v", "Potential at the pin [V]",\
 "battery.cDummy.v", 1, 1, 3, 4)
DeclareVariable("genset.gen.constPDC.pSensor.voltageSensor.n.i", \
"Current flowing into the pin [A]", 237, 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("genset.gen.constPDC.pSensor.voltageSensor.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "battery.cDummy.v", -1, 1, 3, 0)
DeclareVariable("genset.gen.constPDC.pSensor.currentSensor.p.v", \
"Potential at the pin [V]", 238, 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("genset.gen.constPDC.pSensor.currentSensor.p.i", "Current flowing into the pin [A]",\
 "gsPow.pc.i", 1, 5, 461, 132)
DeclareVariable("genset.gen.constPDC.pSensor.currentSensor.n.v", \
"Potential at the pin [V]", 239, 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("genset.gen.constPDC.pSensor.currentSensor.n.i", "Current flowing into the pin [A]",\
 "gsPow.pc.i", -1, 5, 461, 132)
DeclareAlias2("genset.gen.constPDC.pSensor.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "gsPow.pc.i", 1, 5, 461, 0)
DeclareAlias2("genset.gen.constPDC.pSensor.product.u1", "Connector of Real input signal 1",\
 "battery.cDummy.v", -1, 1, 3, 0)
DeclareAlias2("genset.gen.constPDC.pSensor.product.u2", "Connector of Real input signal 2",\
 "gsPow.pc.i", 1, 5, 461, 0)
DeclareAlias2("genset.gen.constPDC.pSensor.product.y", "Connector of Real output signal",\
 "genset.gen.constPDC.feedback1.u2", 1, 5, 496, 0)
DeclareParameter("genset.gen.constPDC.varCond.T_ref", "Reference temperature [K|degC]",\
 112, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("genset.gen.constPDC.varCond.alpha", "Temperature coefficient of conductance (G_actual = G/(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 113, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.gen.constPDC.varCond.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "battery.cDummy.v", -1, 1, 3, 0)
DeclareVariable("genset.gen.constPDC.varCond.p.v", "Potential at the pin [V]", 240,\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("genset.gen.constPDC.varCond.p.i", "Current flowing into the pin [A]",\
 "gsPow.pc.i", 1, 5, 461, 132)
DeclareAlias2("genset.gen.constPDC.varCond.n.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareAlias2("genset.gen.constPDC.varCond.n.i", "Current flowing into the pin [A]",\
 "gsPow.pc.i", -1, 5, 461, 132)
DeclareAlias2("genset.gen.constPDC.varCond.i", "Current flowing from pin p to pin n [A]",\
 "gsPow.pc.i", 1, 5, 461, 0)
DeclareVariable("genset.gen.constPDC.varCond.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 241, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("genset.gen.constPDC.varCond.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 242, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("genset.gen.constPDC.varCond.LossPower", "Loss power leaving component via heatPort [W]",\
 499, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.gen.constPDC.varCond.T_heatPort", "Temperature of heatPort [K|degC]",\
 "genset.gen.constPDC.varCond.T", 1, 5, 242, 0)
DeclareVariable("genset.gen.constPDC.varCond.G_actual", "Actual conductance = G/(1 + alpha*(T_heatPort - T_ref)) [S]",\
 500, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.gen.constPDC.varCond.G", "[S]", "genset.gen.constPDC.integrator1.y", 1,\
 1, 7, 0)
DeclareVariable("genset.gen.constPDC.integrator1.k", "Integrator gain [1]", 243,\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.gen.constPDC.integrator1.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 244, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("genset.gen.constPDC.integrator1.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 245, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("genset.gen.constPDC.integrator1.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 246, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("genset.gen.constPDC.integrator1.y_start", "Initial or guess value of output (= state)",\
 114, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.gen.constPDC.integrator1.u", "Connector of Real input signal",\
 "genset.gen.constPDC.feedback1.y", 1, 5, 497, 0)
DeclareState("genset.gen.constPDC.integrator1.y", "Connector of Real output signal",\
 7, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("genset.gen.constPDC.integrator1.der(y)", "der(Connector of Real output signal)",\
 7, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.gen.constPDC.integrator1.local_reset", "[:#(type=Boolean)]",\
 247, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("genset.gen.constPDC.integrator1.local_set", "", 248, 0, \
0.0,0.0,0.0,0,1537)
DeclareAlias2("genset.gen.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 4)
DeclareAlias2("genset.gen.inertia.flange_a.tau", "Cut torque in the flange [N.m]",\
 "genset.gen.toElePow.tau", 1, 5, 489, 132)
DeclareAlias2("genset.gen.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 4)
DeclareAlias2("genset.gen.inertia.flange_b.tau", "Cut torque in the flange [N.m]",\
 "genset.idealGear.flange_b.tau", -1, 5, 471, 132)
DeclareVariable("genset.gen.inertia.J", "Moment of inertia [kg.m2]", 249, 1, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("genset.gen.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 250, 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("genset.gen.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 0)
DeclareAlias2("genset.gen.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "genset.gen.limTau.w", 1, 5, 484, 0)
DeclareState("genset.gen.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 8, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("genset.gen.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 8, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.gen.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "genset.gen.inertia.der(w)", 1, 6, 8, 0)
DeclareVariable("genset.gen.torque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 251, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("genset.gen.torque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 4)
DeclareAlias2("genset.gen.torque.flange.tau", "Cut torque in the flange [N.m]", \
"genset.gen.toElePow.tau", -1, 5, 489, 132)
DeclareVariable("genset.gen.torque.phi_support", "Absolute angle of support flange [rad|deg]",\
 252, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("genset.gen.torque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "genset.gen.toElePow.tau", 1, 5, 489, 0)
DeclareParameter("genset.gen.gain.k", "Gain value multiplied with input signal [1]",\
 115, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.gen.gain.u", "Input signal connector", "genset.gen.toElePow.applyEta.Pel", 1,\
 5, 494, 0)
DeclareAlias2("genset.gen.gain.y", "Output signal connector", "genset.gen.constPDC.Pref", 1,\
 5, 498, 0)
DeclareAlias2("genset.gen.powSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 4)
DeclareAlias2("genset.gen.powSensor.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "genset.gen.limTau.w", 1, 5, 484, 4)
DeclareAlias2("genset.gen.powSensor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "genset.idealGear.flange_b.tau", 1, 5, 471, 132)
DeclareAlias2("genset.gen.powSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.IcePow.flange_a.phi", 1, 1, 6, 4)
DeclareAlias2("genset.gen.powSensor.flange_b.tau", "Cut torque in the flange [N.m]",\
 "genset.idealGear.flange_b.tau", -1, 5, 471, 132)
DeclareVariable("genset.gen.powSensor.power", "Power in flange flange_a as output signal [W]",\
 501, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.gen.variableLimiter.u", "Connector of Real input signal", \
"genset.gen.tauRef", 1, 5, 502, 0)
DeclareAlias2("genset.gen.variableLimiter.y", "Connector of Real output signal",\
 "genset.gen.toElePow.tau", 1, 5, 489, 0)
DeclareVariable("genset.gen.variableLimiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 253, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.gen.variableLimiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.VariableLimiterHomotopy)]",\
 254, 2, 1.0,3.0,0.0,0,517)
DeclareParameter("genset.gen.variableLimiter.ySimplified", "Fixed value of output in simplified model",\
 116, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.gen.variableLimiter.limit1", "Connector of Real input signal used as maximum of input u",\
 "genset.gen.limTau.yH", 1, 5, 485, 0)
DeclareAlias2("genset.gen.variableLimiter.limit2", "Connector of Real input signal used as minimum of input u",\
 "genset.gen.limTau.yL", 1, 5, 486, 0)
DeclareAlias2("genset.gen.variableLimiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "genset.gen.tauRef", 1, 5, 502, 1024)
DeclareVariable("genset.gen.tauRef", "(positive when motor peration)", 502, 0.0,\
 0.0,0.0,0.0,0,512)
DeclareParameter("genset.mbIce.contrGain", "Proportional controller gain [N.m/W]",\
 117, 0.1, 0.0,0.0,0.0,0,560)
DeclareVariable("genset.mbIce.wIceStart", "[rad/s]", 255, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("genset.mbIce.iceJ", "ICE moment of Inertia [kg.m2]", 118, 10, \
0.0,0.0,0.0,0,560)
DeclareVariable("genset.mbIce.mapsOnFile", "= true, if tables are taken from a txt file [:#(type=Boolean)]",\
 256, true, 0.0,0.0,0.0,0,515)
DeclareParameter("genset.mbIce.maxIceTau[1, 1]", "Maximum ICE generated torque [N.m]",\
 119, 100, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.maxIceTau[1, 2]", "Maximum ICE generated torque [N.m]",\
 120, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.maxIceTau[2, 1]", "Maximum ICE generated torque [N.m]",\
 121, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.maxIceTau[2, 2]", "Maximum ICE generated torque [N.m]",\
 122, 85, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.maxIceTau[3, 1]", "Maximum ICE generated torque [N.m]",\
 123, 300, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.maxIceTau[3, 2]", "Maximum ICE generated torque [N.m]",\
 124, 92, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.maxIceTau[4, 1]", "Maximum ICE generated torque [N.m]",\
 125, 350, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.maxIceTau[4, 2]", "Maximum ICE generated torque [N.m]",\
 126, 98, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.maxIceTau[5, 1]", "Maximum ICE generated torque [N.m]",\
 127, 400, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.maxIceTau[5, 2]", "Maximum ICE generated torque [N.m]",\
 128, 98, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[1, 1]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 129, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[1, 2]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 130, 100.0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[1, 3]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 131, 200.0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[1, 4]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 132, 300.0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[1, 5]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 133, 400.0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[1, 6]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 134, 500.0, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[2, 1]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 135, 10, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[2, 2]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 136, 630, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[2, 3]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 137, 580, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[2, 4]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 138, 550, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[2, 5]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 139, 580, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[2, 6]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 140, 630, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[3, 1]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 141, 20, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[3, 2]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 142, 430, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[3, 3]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 143, 420, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[3, 4]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 144, 400, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[3, 5]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 145, 400, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[3, 6]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 146, 450, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[4, 1]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 147, 30, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[4, 2]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 148, 320, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[4, 3]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 149, 325, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[4, 4]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 150, 330, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[4, 5]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 151, 340, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[4, 6]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 152, 350, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[5, 1]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 153, 40, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[5, 2]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 154, 285, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[5, 3]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 155, 285, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[5, 4]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 156, 288, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[5, 5]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 157, 290, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[5, 6]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 158, 300, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[6, 1]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 159, 50, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[6, 2]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 160, 270, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[6, 3]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 161, 265, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[6, 4]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 162, 265, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[6, 5]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 163, 270, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[6, 6]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 164, 275, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[7, 1]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 165, 60, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[7, 2]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 166, 255, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[7, 3]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 167, 248, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[7, 4]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 168, 250, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[7, 5]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 169, 255, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[7, 6]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 170, 258, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[8, 1]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 171, 70, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[8, 2]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 172, 245, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[8, 3]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 173, 237, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[8, 4]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 174, 238, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[8, 5]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 175, 243, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[8, 6]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 176, 246, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[9, 1]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 177, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[9, 2]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 178, 245, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[9, 3]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 179, 230, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[9, 4]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 180, 233, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[9, 5]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 181, 237, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[9, 6]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 182, 240, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[10, 1]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 183, 90, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[10, 2]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 184, 235, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[10, 3]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 185, 230, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[10, 4]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 186, 228, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[10, 5]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 187, 233, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.specificCons[10, 6]", "ICE specific consumption map. First column torque, first row speed [g/(kW.h)]",\
 188, 235, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.mbIce.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.speedSensor.flange.phi", 1, 5, 469, 4)
DeclareVariable("genset.mbIce.inertia.flange_a.tau", "Cut torque in the flange [N.m]",\
 503, 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("genset.mbIce.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.speedSensor.flange.phi", 1, 5, 469, 4)
DeclareAlias2("genset.mbIce.inertia.flange_b.tau", "Cut torque in the flange [N.m]",\
 "genset.idealGear.flange_a.tau", -1, 5, 470, 132)
DeclareVariable("genset.mbIce.inertia.J", "Moment of inertia [kg.m2]", 257, 1, \
0.0,1E+100,0.0,0,513)
DeclareVariable("genset.mbIce.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 258, 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("genset.mbIce.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "genset.speedSensor.flange.phi", 1, 5, 469, 0)
DeclareAlias2("genset.mbIce.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareVariable("genset.mbIce.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s|rpm]",\
 504, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.mbIce.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 505, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.mbIce.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "genset.mbIce.inertia.der(w)", 1, 5, 505, 0)
DeclareVariable("genset.mbIce.iceTau.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 259, false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("genset.mbIce.iceTau.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.speedSensor.flange.phi", 1, 5, 469, 4)
DeclareAlias2("genset.mbIce.iceTau.flange.tau", "Cut torque in the flange [N.m]",\
 "genset.mbIce.inertia.flange_a.tau", -1, 5, 503, 132)
DeclareVariable("genset.mbIce.iceTau.phi_support", "Absolute angle of support flange [rad|deg]",\
 260, 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("genset.mbIce.iceTau.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "genset.mbIce.inertia.flange_a.tau", 1, 5, 503, 0)
DeclareAlias2("genset.mbIce.icePow.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.speedSensor.flange.phi", 1, 5, 469, 4)
DeclareAlias2("genset.mbIce.icePow.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "genset.mbIce.inertia.w", 1, 5, 504, 4)
DeclareAlias2("genset.mbIce.icePow.flange_a.tau", "Cut torque in the flange [N.m]",\
 "genset.idealGear.flange_a.tau", 1, 5, 470, 132)
DeclareAlias2("genset.mbIce.icePow.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.speedSensor.flange.phi", 1, 5, 469, 4)
DeclareAlias2("genset.mbIce.icePow.flange_b.tau", "Cut torque in the flange [N.m]",\
 "genset.idealGear.flange_a.tau", -1, 5, 470, 132)
DeclareVariable("genset.mbIce.icePow.power", "Power in flange flange_a as output signal [W]",\
 506, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.mbIce.w.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.speedSensor.flange.phi", 1, 5, 469, 4)
DeclareAlias2("genset.mbIce.w.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "genset.mbIce.inertia.w", 1, 5, 504, 4)
DeclareVariable("genset.mbIce.w.flange.tau", "Cut torque in the flange [N.m]", 261,\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("genset.mbIce.w.w", "Absolute angular velocity of flange as output signal [rad/s]",\
 "genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareAlias2("genset.mbIce.toPowW.u1", "Connector of Real input signal 1", \
"genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareAlias2("genset.mbIce.toPowW.u2", "Connector of Real input signal 2", \
"genset.mbIce.inertia.flange_a.tau", 1, 5, 503, 0)
DeclareVariable("genset.mbIce.toPowW.y", "Connector of Real output signal", 507,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.mbIce.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "genset.speedSensor.flange.phi", 1, 5, 469, 4)
DeclareAlias2("genset.mbIce.flange_a.tau", "Cut torque in the flange [N.m]", \
"genset.idealGear.flange_a.tau", -1, 5, 470, 132)
DeclareAlias2("genset.mbIce.toGramsPerkWh.u1", "Connector of Real input signal 1",\
 "genset.mbIce.inertia.flange_a.tau", 1, 5, 503, 0)
DeclareAlias2("genset.mbIce.toGramsPerkWh.u2", "Connector of Real input signal 2",\
 "genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareVariable("genset.mbIce.toGramsPerkWh.y", "Connector of Real output signal",\
 508, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.mbIce.toGramsPerkWh.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 262, true, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[1, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 263, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[1, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 264, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[1, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 265, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[1, 4]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 266, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[1, 5]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 267, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[1, 6]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 268, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[2, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 269, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[2, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 270, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[2, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 271, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[2, 4]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 272, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[2, 5]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 273, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[2, 6]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 274, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[3, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 275, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[3, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 276, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[3, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 277, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[3, 4]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 278, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[3, 5]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 279, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[3, 6]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 280, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[4, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 281, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[4, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 282, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[4, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 283, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[4, 4]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 284, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[4, 5]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 285, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[4, 6]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 286, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[5, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 287, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[5, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 288, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[5, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 289, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[5, 4]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 290, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[5, 5]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 291, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[5, 6]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 292, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[6, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 293, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[6, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 294, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[6, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 295, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[6, 4]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 296, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[6, 5]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 297, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[6, 6]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 298, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[7, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 299, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[7, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 300, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[7, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 301, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[7, 4]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 302, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[7, 5]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 303, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[7, 6]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 304, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[8, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 305, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[8, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 306, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[8, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 307, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[8, 4]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 308, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[8, 5]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 309, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[8, 6]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 310, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[9, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 311, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[9, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 312, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[9, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 313, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[9, 4]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 314, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[9, 5]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 315, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[9, 6]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 316, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[10, 1]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 317, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[10, 2]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 318, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[10, 3]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 319, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[10, 4]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 320, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[10, 5]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 321, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.table[10, 6]", "Table matrix (grid u1 = first column, grid u2 = first row; e.g., table=[0, 0; 0, 1])",\
 322, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("genset.mbIce.toGramsPerkWh.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 189, true, 0.0,0.0,0.0,0,562)
DeclareVariable("genset.mbIce.toGramsPerkWh.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 323, 1, 1.0,6.0,0.0,0,517)
DeclareVariable("genset.mbIce.toGramsPerkWh.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 324, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("genset.mbIce.toGramsPerkWh.verboseExtrapolation", \
"= true, if warning messages are to be printed if table input is outside the definition range [:#(type=Boolean)]",\
 325, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.mbIce.toGramsPerkWh.u_min[1]", "Minimum abscissa value defined in table",\
 326, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.u_min[2]", "Minimum abscissa value defined in table",\
 327, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.u_max[1]", "Maximum abscissa value defined in table",\
 328, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.u_max[2]", "Maximum abscissa value defined in table",\
 329, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toGramsPerkWh.tableID.id", "[:#(type=Integer)]", 330,\
 0, 0.0,0.0,0.0,0,2565)
DeclareParameter("genset.mbIce.tokW.k", "Gain value multiplied with input signal [1]",\
 190, 0.001, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.mbIce.tokW.u", "Input signal connector", "genset.mbIce.toPowW.y", 1,\
 5, 507, 0)
DeclareVariable("genset.mbIce.tokW.y", "Output signal connector", 509, 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("genset.mbIce.toG_perHour.u1", "Connector of Real input signal 1",\
 "genset.mbIce.toGramsPerkWh.y", 1, 5, 508, 0)
DeclareVariable("genset.mbIce.toG_perHour.u2", "Connector of Real input signal 2",\
 510, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.mbIce.toG_perHour.y", "Connector of Real output signal", \
"genset.mbIce.fuelCons", 1, 5, 513, 0)
DeclareParameter("genset.mbIce.tokgFuel.k", "Integrator gain [1]", 191, \
2.7777777777777776E-07, 0.0,0.0,0.0,0,560)
DeclareVariable("genset.mbIce.tokgFuel.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 331, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("genset.mbIce.tokgFuel.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 332, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("genset.mbIce.tokgFuel.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 333, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("genset.mbIce.tokgFuel.y_start", "Initial or guess value of output (= state)",\
 192, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.mbIce.tokgFuel.u", "Connector of Real input signal", \
"genset.mbIce.fuelCons", 1, 5, 513, 0)
DeclareState("genset.mbIce.tokgFuel.y", "Connector of Real output signal", 9, \
0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("genset.mbIce.tokgFuel.der(y)", "der(Connector of Real output signal)",\
 9, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.mbIce.tokgFuel.local_reset", "[:#(type=Boolean)]", 334, \
false, 0.0,0.0,0.0,0,1539)
DeclareVariable("genset.mbIce.tokgFuel.local_set", "", 335, 0, 0.0,0.0,0.0,0,1537)
DeclareAlias2("genset.mbIce.switch1.u1", "Connector of first Real input signal",\
 "genset.mbIce.tokW.y", 1, 5, 509, 0)
DeclareAlias2("genset.mbIce.switch1.u2", "Connector of Boolean input signal [:#(type=Boolean)]",\
 "genset.mbIce.onSignal.k", 1, 7, 197, 65)
DeclareAlias2("genset.mbIce.switch1.u3", "Connector of second Real input signal",\
 "genset.mbIce.zero.k", 1, 7, 193, 0)
DeclareAlias2("genset.mbIce.switch1.y", "Connector of Real output signal", \
"genset.mbIce.toG_perHour.u2", 1, 5, 510, 0)
DeclareParameter("genset.mbIce.zero.k", "Constant output value", 193, 0, \
0.0,0.0,0.0,0,560)
DeclareAlias2("genset.mbIce.zero.y", "Connector of Real output signal", \
"genset.mbIce.zero.k", 1, 7, 193, 0)
DeclareVariable("genset.mbIce.toLimTau.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 336, 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("genset.mbIce.toLimTau.u[1]", "Connector of Real input signals", \
"genset.mbIce.inertia.w", 1, 5, 504, 0)
DeclareVariable("genset.mbIce.toLimTau.y[1]", "Connector of Real output signals",\
 511, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.mbIce.toLimTau.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 337, true, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.mbIce.toLimTau.table[1, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 338, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.table[1, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 339, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.table[2, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 340, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.table[2, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 341, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.table[3, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 342, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.table[3, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 343, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.table[4, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 344, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.table[4, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 345, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.table[5, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 346, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.table[5, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 347, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("genset.mbIce.toLimTau.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 194, true, 0.0,0.0,0.0,0,562)
DeclareVariable("genset.mbIce.toLimTau.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 348, 2, 0.0,0.0,0.0,0,517)
DeclareVariable("genset.mbIce.toLimTau.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 349, 1, 1.0,6.0,0.0,0,517)
DeclareVariable("genset.mbIce.toLimTau.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 350, 2, 1.0,4.0,0.0,0,517)
DeclareVariable("genset.mbIce.toLimTau.verboseExtrapolation", "= true, if warning messages are to be printed if table input is outside the definition range [:#(type=Boolean)]",\
 351, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.mbIce.toLimTau.u_min", "Minimum abscissa value defined in table",\
 352, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.u_max", "Maximum abscissa value defined in table",\
 353, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("genset.mbIce.toLimTau.tableID.id", "[:#(type=Integer)]", 354, 0,\
 0.0,0.0,0.0,0,2565)
DeclareAlias2("genset.mbIce.rotorW.y", "Value of Real output", "genset.mbIce.inertia.w", 1,\
 5, 504, 0)
DeclareAlias2("genset.mbIce.product.u1", "Connector of Real input signal 1", \
"genset.mbIce.toLimTau.y[1]", 1, 5, 511, 0)
DeclareVariable("genset.mbIce.product.u2", "Connector of Real input signal 2", 512,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("genset.mbIce.product.y", "Connector of Real output signal", \
"genset.mbIce.inertia.flange_a.tau", 1, 5, 503, 0)
DeclareParameter("genset.mbIce.limiter.uMax", "Upper limits of input signals", 195,\
 1, 0.0,0.0,0.0,0,560)
DeclareParameter("genset.mbIce.limiter.uMin", "Lower limits of input signals", 196,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("genset.mbIce.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 355, false, 0.0,0.0,0.0,0,515)
DeclareVariable("genset.mbIce.limiter.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 356, 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("genset.mbIce.limiter.u", "Connector of Real input signal", \
"genset.gms.throttle", 1, 5, 478, 0)
DeclareAlias2("genset.mbIce.limiter.y", "Connector of Real output signal", \
"genset.mbIce.product.u2", 1, 5, 512, 0)
DeclareAlias2("genset.mbIce.limiter.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "genset.gms.throttle", 1, 5, 478, 1024)
DeclareAlias2("genset.mbIce.nTauRef", "normalized torque request", \
"genset.gms.throttle", 1, 5, 478, 0)
DeclareVariable("genset.mbIce.fuelCons", "Fuel consumption (g/h)", 513, 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("genset.mbIce.onSignal.k", "Constant output value [:#(type=Boolean)]",\
 197, true, 0.0,0.0,0.0,0,562)
DeclareAlias2("genset.mbIce.onSignal.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "genset.mbIce.onSignal.k", 1, 7, 197, 65)
DeclareVariable("genset.revGain.k", "Gain value multiplied with input signal [1]",\
 357, 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("genset.revGain.u", "Input signal connector", "genset.gms.tRef", 1,\
 5, 477, 0)
DeclareAlias2("genset.revGain.y", "Output signal connector", "genset.gen.tauRef", 1,\
 5, 502, 0)
DeclareParameter("genset.toGrams.k", "Integrator gain [1]", 198, \
0.0002777777777777778, 0.0,0.0,0.0,0,560)
DeclareVariable("genset.toGrams.use_reset", "= true, if reset port enabled [:#(type=Boolean)]",\
 358, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("genset.toGrams.use_set", "= true, if set port enabled and used as reinitialization value when reset [:#(type=Boolean)]",\
 359, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("genset.toGrams.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 360, 3, 1.0,4.0,0.0,0,517)
DeclareParameter("genset.toGrams.y_start", "Initial or guess value of output (= state)",\
 199, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("genset.toGrams.u", "Connector of Real input signal", \
"genset.mbIce.fuelCons", 1, 5, 513, 0)
DeclareState("genset.toGrams.y", "Connector of Real output signal", 10, 0.0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("genset.toGrams.der(y)", "der(Connector of Real output signal)",\
 10, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("genset.toGrams.local_reset", "[:#(type=Boolean)]", 361, false, \
0.0,0.0,0.0,0,1539)
DeclareVariable("genset.toGrams.local_set", "", 362, 0, 0.0,0.0,0.0,0,1537)
DeclareParameter("driver.k", "Controller gain", 200, 200.0, 0.0,0.0,0.0,0,560)
DeclareParameter("driver.yMax", "Max output value (absolute)", 201, 2000.0, \
0.0,0.0,0.0,0,560)
DeclareVariable("driver.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 363, 3, 1.0,4.0,0.0,0,517)
DeclareVariable("driver.dummy", "[:#(type=Boolean)]", 364, false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("driver.V", "", "mass.v", 1, 5, 412, 0)
DeclareVariable("driver.from_kmh.u", "Connector of Real input signal to be converted [km/h]",\
 514, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("driver.from_kmh.y", "Connector of Real output signal containing input signal u in another unit [m/s]",\
 515, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("driver.driveCyc.nout", "Number of outputs [:#(type=Integer)]", 365,\
 1, 1.0,1E+100,0.0,0,517)
DeclareAlias2("driver.driveCyc.y[1]", "Connector of Real output signals", \
"driver.from_kmh.u", 1, 5, 514, 0)
DeclareVariable("driver.driveCyc.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 366, true, 0.0,0.0,0.0,0,515)
DeclareParameter("driver.driveCyc.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 202, true, 0.0,0.0,0.0,0,562)
DeclareParameter("driver.driveCyc.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 203, 2, 0.0,0.0,0.0,0,564)
DeclareVariable("driver.driveCyc.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 367, 1, 1.0,6.0,0.0,0,517)
DeclareVariable("driver.driveCyc.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 368, 3, 1.0,4.0,0.0,0,517)
DeclareVariable("driver.driveCyc.timeScale", "Time scale of first table column [s]",\
 369, 1, 1E-15,1E+100,0.0,0,513)
DeclareParameter("driver.driveCyc.offset[1]", "Offsets of output signals", 204, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("driver.driveCyc.startTime", "Output = offset for time < startTime [s]",\
 205, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("driver.driveCyc.shiftTime", "Shift time of first table column [s]",\
 370, 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("driver.driveCyc.timeEvents", "Time event handling of table interpolation [:#(type=Modelica.Blocks.Types.TimeEvents)]",\
 206, 1, 1.0,3.0,0.0,0,564)
DeclareVariable("driver.driveCyc.verboseExtrapolation", "= true, if warning messages are to be printed if time is outside the table definition range [:#(type=Boolean)]",\
 371, false, 0.0,0.0,0.0,0,515)
DeclareVariable("driver.driveCyc.t_min", "Minimum abscissa value defined in table [s]",\
 372, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("driver.driveCyc.t_max", "Maximum abscissa value defined in table [s]",\
 373, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("driver.driveCyc.t_minScaled", "Minimum (scaled) abscissa value defined in table",\
 374, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("driver.driveCyc.t_maxScaled", "Maximum (scaled) abscissa value defined in table",\
 375, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("driver.driveCyc.p_offset[1]", "Offsets of output signals", 376,\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("driver.driveCyc.tableID.id", "[:#(type=Integer)]", 377, 0, \
0.0,0.0,0.0,0,2565)
DeclareVariable("driver.driveCyc.nextTimeEvent", "Next time event instant [s]", 403,\
 0, 0.0,0.0,0.0,0,2704)
DeclareVariable("driver.driveCyc.nextTimeEventScaled", "Next scaled time event instant",\
 404, 0, 0.0,0.0,0.0,0,2704)
DeclareVariable("driver.driveCyc.timeScaled", "Scaled time", 516, 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareAlias2("driver.feedback.u1", "Commanded input", "driver.from_kmh.y", 1, 5,\
 515, 0)
DeclareAlias2("driver.feedback.u2", "Feedback input", "mass.v", 1, 5, 412, 0)
DeclareVariable("driver.feedback.y", "", 517, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("driver.gain.k", "Gain value multiplied with input signal [1]", 378,\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("driver.gain.u", "Input signal connector", "driver.feedback.y", 1,\
 5, 517, 0)
DeclareVariable("driver.gain.y", "Output signal connector", 518, 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("driver.limAcc.uMax", "Upper limits of input signals", 379, 1, \
0.0,0.0,0.0,0,513)
DeclareParameter("driver.limAcc.uMin", "Lower limits of input signals", 207, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("driver.limAcc.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 380, false, 0.0,0.0,0.0,0,515)
DeclareVariable("driver.limAcc.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 381, 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("driver.limAcc.u", "Connector of Real input signal", \
"driver.gain.y", 1, 5, 518, 0)
DeclareAlias2("driver.limAcc.y", "Connector of Real output signal", \
"driver.accelTau", 1, 5, 519, 0)
DeclareAlias2("driver.limAcc.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "driver.gain.y", 1, 5, 518, 1024)
DeclareParameter("driver.limBrak.uMax", "Upper limits of input signals", 208, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("driver.limBrak.uMin", "Lower limits of input signals", 382, 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("driver.limBrak.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 383, false, 0.0,0.0,0.0,0,515)
DeclareVariable("driver.limBrak.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 384, 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("driver.limBrak.u", "Connector of Real input signal", \
"driver.gain.y", 1, 5, 518, 0)
DeclareAlias2("driver.limBrak.y", "Connector of Real output signal", \
"driver.brakeTau", 1, 5, 520, 0)
DeclareAlias2("driver.limBrak.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "driver.gain.y", 1, 5, 518, 1024)
DeclareAlias2("driver.tauRef", "[N.m]", "drive.tauRef", 1, 5, 460, 0)
DeclareVariable("driver.accelTau", "[N.m]", 519, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("driver.brakeTau", "[N.m]", 520, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("driver.limiter1.uMax", "Upper limits of input signals", 385, 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("driver.limiter1.uMin", "Lower limits of input signals", 386, \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("driver.limiter1.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 387, false, 0.0,0.0,0.0,0,515)
DeclareVariable("driver.limiter1.homotopyType", "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 388, 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("driver.limiter1.u", "Connector of Real input signal", \
"driver.gain.y", 1, 5, 518, 0)
DeclareAlias2("driver.limiter1.y", "Connector of Real output signal", \
"drive.tauRef", 1, 5, 460, 0)
DeclareAlias2("driver.limiter1.simplifiedExpr", "Simplified expression for homotopy-based initialization",\
 "driver.gain.y", 1, 5, 518, 1024)
DeclareAlias2("drivePow.pc.v", "Potential at the pin [V]", "battery.cDummy.v", 1,\
 1, 3, 4)
DeclareAlias2("drivePow.pc.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", -1, 5, 451, 132)
DeclareAlias2("drivePow.nc.v", "Potential at the pin [V]", "battery.cDummy.v", 1,\
 1, 3, 4)
DeclareAlias2("drivePow.nc.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", 1, 5, 451, 132)
DeclareAlias2("drivePow.pv.v", "Potential at the pin [V]", "battery.cDummy.v", 1,\
 1, 3, 4)
DeclareVariable("drivePow.pv.i", "Current flowing into the pin [A]", 389, 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("drivePow.nv.v", "Potential at the pin [V]", 390, 0.0, 0.0,0.0,\
0.0,0,521)
DeclareVariable("drivePow.nv.i", "Current flowing into the pin [A]", 391, 0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("drivePow.power", "Instantaneous power as output signal [W]", \
"ems.edPow", 1, 5, 467, 0)
DeclareAlias2("drivePow.voltageSensor.p.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareVariable("drivePow.voltageSensor.p.i", "Current flowing into the pin [A]",\
 392, 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drivePow.voltageSensor.n.v", "Potential at the pin [V]", 393, \
0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drivePow.voltageSensor.n.i", "Current flowing into the pin [A]",\
 394, 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drivePow.voltageSensor.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 "battery.cDummy.v", 1, 1, 3, 0)
DeclareAlias2("drivePow.currentSensor.p.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareAlias2("drivePow.currentSensor.p.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", -1, 5, 451, 132)
DeclareAlias2("drivePow.currentSensor.n.v", "Potential at the pin [V]", \
"battery.cDummy.v", 1, 1, 3, 4)
DeclareAlias2("drivePow.currentSensor.n.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", 1, 5, 451, 132)
DeclareAlias2("drivePow.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "drive.pin_p.i", -1, 5, 451, 0)
DeclareAlias2("drivePow.product.u1", "Connector of Real input signal 1", \
"battery.cDummy.v", 1, 1, 3, 0)
DeclareAlias2("drivePow.product.u2", "Connector of Real input signal 2", \
"drive.pin_p.i", -1, 5, 451, 0)
DeclareAlias2("drivePow.product.y", "Connector of Real output signal", \
"ems.edPow", 1, 5, 467, 0)
DeclareState("stateSelect.set1.x[1]", "", 11, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("stateSelect.set1.der(x[1])", "", 11, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("stateSelect.set1.P[1, 1]", "", 521, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("stateSelect.set1.P[1, 2]", "", 522, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("stateSelect.set1.P[1, 3]", "", 523, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
preD(DYNX(W_,398),"dragForce.mode", 3, 0);
pre(DYNX(W_,400),"drive.limTau.state", 0, 3);
pre(DYNX(W_,403),"driver.driveCyc.nextTimeEvent", 0, 5);
preD(DYNX(W_,404),"driver.driveCyc.nextTimeEventScaled", 0, 1);
preD(DYNX(W_,401),"ems.powHyst.y", false, 2);
pre(DYNX(W_,402),"genset.gen.limTau.state", 0, 4);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(W_,422), 0.0, 5);
DoRemember_(DYNX(W_,428), 0.0, 6);
DoRemember_(DYNX(F_,2), 0.0, 8);
DoRemember_(DYNX(F_,1), 0.0, 7);
DoRemember_(DYNX(F_,3), 0.0, 10);
DoRemember_(DYNX(F_,8), 0.0, 9);
DoRemember_(DYNX(F_,0), 0.0, 0);
DoRemember_(DYNX(W_,406), 0.0, 4);
DoRemember_(DYNX(W_,418), 0.0, 3);
DoRemember_(DYNX(W_,457), 0.0, 1);
DoRemember_(DYNX(W_,412), 0, 2);
EndEqBlock
UpdateQEvaluate(2)
EndDataBlock

BreakSectionFunctionStart(2);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(3);
BreakSectionFunctionEnd()
